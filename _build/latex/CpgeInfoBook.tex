%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsable pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Informatique en CPGE}
\date{Feb 19, 2023}
\release{}
\author{El Hadiq Zouhair}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{intro::doc}}


\sphinxAtStartPar
This is a small sample book to give you a feel for how book content is
structured.
It shows off a few of the major file types, as well as some sample content.
It does not go in\sphinxhyphen{}depth into any particular topic \sphinxhyphen{} check out \sphinxhref{https://jupyterbook.org}{the Jupyter Book documentation} for more information.

\sphinxAtStartPar
Check out the content pages bundled with this sample book to see more.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\Large Table des matieres}
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{notebooks/Arbres-binaires/Arbres::doc}]{\sphinxcrossref{Arbres binaires}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{notebooks/ABR/ABR::doc}]{\sphinxcrossref{Arbres Binaires de Recherche}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{notebooks/dynamicProgramming/ProgrammationDynamique::doc}]{\sphinxcrossref{Programmation dynamique}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{notebooks/dynamicProgramming/glouton::doc}]{\sphinxcrossref{Les algorithmes gloutons}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES::doc}]{\sphinxcrossref{TRAITEMENT DES IMAGES}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{notebooks/Machine-Learning/KNN-Cours::doc}]{\sphinxcrossref{Algorithme KNN: Cours}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{notebooks/Machine-Learning/TP-Iris::doc}]{\sphinxcrossref{Tp Iris}}}

\end{itemize}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large bibliography}
\end{DUlineblock}


\chapter{Arbres binaires}
\label{\detokenize{notebooks/Arbres-binaires/Arbres:arbres-binaires}}\label{\detokenize{notebooks/Arbres-binaires/Arbres::doc}}

\section{Définition formelle d’un arbre binaire}
\label{\detokenize{notebooks/Arbres-binaires/Arbres:definition-formelle-dun-arbre-binaire}}
\sphinxAtStartPar
On appelle arité d’un nœud le nombre de branches qui en partent 3 . Dans la suite de notre cours, nous nous intéresserons plus particulièrement aux arbres binaires, c’est à dire ceux dont chaque nœud a au plus deux fils.
Pour ne pas avoir à distinguer les nœuds suivant leur arité, il est pratique d’ajouter à l’ensemble des arbres binaires un arbre particulier appelé l’arbre vide. Ceci conduit à adopter la définition qui suit.



\sphinxAtStartPar
x est l’étiquette de la racine de A ; quant à Fg et Fd , ils sont appelés respectivement le sous\sphinxhyphen{}arbre gauche et le sous\sphinxhyphen{}arbre droit de l’arbre binaire A.
De manière usuelle, on convient de ne pas faire figurer l’arbre vide dans les représentations graphiques des arbres binaires. Ainsi, suivant la représentation choisie les feuilles pourront désigner exclusivement l’arbre vide (et dans ce cas tous les nœuds seront d’arité égale à 2) ou alors les nœuds dont les deux fils sont vides (dans ce cas l’arité d’un nœud pourra être égale à 0, 1 ou 2). C’est cette seconde convention qui sera utilisée dans la suite de ce cours.

\sphinxAtStartPar
\sphinxstylestrong{Définition.} La \sphinxstylestrong{taille(A)} d’un arbre A est définie inductivement par les relations :
\begin{quote}

\sphinxAtStartPar
taille({[}  {]}) = 0 ;
Si A = (Fg , x, Fd ) alors taille(A)= 1 + taille(Fg) + taille(Fd).
\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{Définition.} \sphinxstylestrong{La hauteur}: h(A) d’un arbre A se définit inductivement par les relations :
\begin{quote}

\sphinxAtStartPar
h({[} {]}) = 0 ;
Si A = (Fg , x, Fd ) alors h(A) = 1 + max(h(Fg ), h(Fd )).
\end{quote}

\sphinxAtStartPar
Avec ces conventions, taille(A) est le nombre de nœuds d’un arbre et h(A) la longueur maximale du chemin reliant la racine à une feuille, autrement dit la profondeur maximale d’un nœud.
La définition Python de ces fonctions est immédiate :
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Vide}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{f1}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Vide}\PYG{p}{,}\PYG{n}{Vide}\PYG{p}{]}
\PYG{n}{f0}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f2}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{f1}\PYG{p}{,}\PYG{n}{f0}\PYG{p}{]}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f2}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[1, [1, [], []], [0, [], []]]
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{FiboA}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{n}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{]}
    \PYG{n}{Fg}\PYG{o}{=}\PYG{n}{FiboA}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{Fd}\PYG{o}{=}\PYG{n}{FiboA}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{racine}\PYG{o}{=}\PYG{n}{Fg}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{n}{Fd}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{racine}\PYG{p}{,}\PYG{n}{Fg}\PYG{p}{,}\PYG{n}{Fd}\PYG{p}{]}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}

\sphinxAtStartPar
\sphinxincludegraphics{{fibtree5}.png}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{F4}\PYG{o}{=}\PYG{n}{FiboA}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{taille}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{A}\PYG{o}{==}\PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+m+mi}{0}
    \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{taille}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{n}{taille}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{hauteur}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{A}\PYG{o}{==}\PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+m+mi}{0}
    \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{hauteur}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{hauteur}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hauteur}\PYG{p}{(}\PYG{n}{F4}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
4
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{parcour\PYGZus{}prefixe}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{A}\PYG{o}{==}\PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{o}{+}\PYG{n}{parcour\PYGZus{}prefixe}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{n}{parcour\PYGZus{}prefixe}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{parcour\PYGZus{}postfixe}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{A}\PYG{o}{==}\PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{parcour\PYGZus{}postfixe}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{n}{parcour\PYGZus{}postfixe}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{p}{[}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{parcour\PYGZus{}prefixe}\PYG{p}{(}\PYG{n}{F4}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[3, 2, 1, 1, 0, 1, 1, 1, 0]
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{parcour\PYGZus{}infixe}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{A}\PYG{o}{==}\PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{parcour\PYGZus{}infixe}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{p}{[}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{o}{+}\PYG{n}{parcour\PYGZus{}infixe}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{prefixe: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{parcour\PYGZus{}prefixe}\PYG{p}{(}\PYG{n}{F4}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{postfixe: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{parcour\PYGZus{}postfixe}\PYG{p}{(}\PYG{n}{F4}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{infixe: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{parcour\PYGZus{}infixe}\PYG{p}{(}\PYG{n}{F4}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
prefixe:  [3, 2, 1, 1, 0, 1, 1, 1, 0]
postfixe:  [1, 0, 1, 1, 2, 1, 0, 1, 3]
infixe:  [1, 1, 0, 2, 1, 3, 1, 1, 0]
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{parcour\PYGZus{}en\PYGZus{}largeur}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{L1}\PYG{p}{,}\PYG{n}{L2}\PYG{o}{=}\PYG{p}{[}\PYG{n}{A}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}
    \PYG{n}{larg}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
    \PYG{k}{while} \PYG{n}{L1}\PYG{o}{!=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{E} \PYG{o+ow}{in} \PYG{n}{L1}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{E}\PYG{o}{!=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
                \PYG{n}{larg}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{E}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
                \PYG{n}{L2}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{p}{[}\PYG{n}{E}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{E}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{L1}\PYG{o}{=}\PYG{n}{L2}
        \PYG{n}{L2}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{larg}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{parcour\PYGZus{}en\PYGZus{}largeur}\PYG{p}{(}\PYG{n}{FiboA}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[3, 2, 1, 1, 1, 1, 0, 1, 0]
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{La taille de F(4) est }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{, et son hauteur est }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{taille}\PYG{p}{(}\PYG{n}{F4}\PYG{p}{)}\PYG{p}{,}\PYG{n}{hauteur}\PYG{p}{(}\PYG{n}{F4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
La taille de F(4) est 9, et son hauteur est 4
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}


\chapter{Arbres Binaires de Recherche}
\label{\detokenize{notebooks/ABR/ABR:arbres-binaires-de-recherche}}\label{\detokenize{notebooks/ABR/ABR::doc}}


\sphinxAtStartPar
\sphinxstylestrong{Indication}:  Concernant les cellules qui contiens des théorèmes enlever le commenatire (< !– – >) pour visualiser la preuve apres avoir essayer le prouvé vous meme  
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{random}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}


\bigskip\hrule\bigskip


\sphinxAtStartPar
Un arbre binaire de recherche {[}\hyperlink{cite.intro:id7}{Jean\sphinxhyphen{}Pierre\sphinxhyphen{}Becirspahic., n.d.}{]} (en abrégé : ABR) permet l’implémentation sous forme d’arbre binaire de certaines structures de données stockant des éléments formés d’une clé et d’une valeur, tels les dictionnaires 7.
Nous allons donc considérer un ensemble ordonné de clés \(C\) ainsi qu’un ensemble de valeurs \(V\), et utiliser des arbres binaires étiquetés par \(E = C × V.\)
Les arbre binaire de recherche supportent nombre d’opérations qu’on utilise dans les structures de données, en particulier :
\begin{itemize}
\item {} 
\sphinxAtStartPar
la recherche d’un valeur associée à une clé donnée ;

\item {} 
\sphinxAtStartPar
la recherche de la valeur associée à la clé maximale (ou minimale) ;

\item {} 
\sphinxAtStartPar
la recherche du successeur d’une clé c, c’est à dire la valeur associée à la plus petite des clés strictement supérieures à c ;

\item {} 
\sphinxAtStartPar
la recherche du prédécesseur d’une clé ;

\item {} 
\sphinxAtStartPar
et bien sûr l’insertion ou la suppression d’un nouveau couple clé/valeur.

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{abr}.png}

\sphinxAtStartPar
Figure 1 – Un exemple d’arbre binaire de recherche (seules les clés ont été représentées)

\sphinxAtStartPar
\sphinxstylestrong{Définition.}
un arbre binaire \(A\) est un arbre binaire de recherche s’il est vide ou égal à \([(c,v),Fg, Fd]\) où :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(Fg\) et \(Fd\) sont des arbres binaires de recherche ;

\item {} 
\sphinxAtStartPar
toute clé de \(Fg\) est inférieure (ou égale ) à \(c\) ;

\item {} 
\sphinxAtStartPar
toute clé de \(Fd\) est supérieure (ou égale) à \(c\).

\end{itemize}

\sphinxAtStartPar
Autrement dit, A est un arbre binaire de recherche lorsque tout nœud de A est associé à une clé supérieure ou
égale à toute clé de son fils gauche, et inférieure ou égale à toute clé de son fils droit.



\sphinxAtStartPar
\sphinxstylestrong{Theorème.} Lors du parcours infixe d’un arbre binaire de recherche, les clés sont parcourues par ordre croissant.

\sphinxAtStartPar
\sphinxstylestrong{Preuve.} On \sphinxstylestrong{procède} par induction :
\begin{itemize}
\item {} 
\sphinxAtStartPar
si A = {[} {]}, il n’y a rien à prouver ;

\item {} 
\sphinxAtStartPar
si A = {[}x,Fg,Fd{]}, on suppose que les parcours infixes de Fg et de Fd se font par ordre de clés croissantes.
Sachant que toute clé de Fg est inférieure à la clé de x et toute clé de Fd supérieure à cette dernière, le parcours \$\(Fg \rightarrow x\rightarrow Fd\)\$ est bien effectué par ordre croissant de clé.
–>

\end{itemize}




\section{Insertion et suppression}
\label{\detokenize{notebooks/ABR/ABR:insertion-et-suppression}}

\subsection{1. Insertion et suppression dans un arbre binaire de recherche quelconque}
\label{\detokenize{notebooks/ABR/ABR:insertion-et-suppression-dans-un-arbre-binaire-de-recherche-quelconque}}

\subsubsection{Insertion}
\label{\detokenize{notebooks/ABR/ABR:insertion}}
\sphinxAtStartPar
Pour insérer le couple \((k;u) \in C×V\) dans l’arbre \(A\) on procède ainsi :
\begin{itemize}
\item {} 
\sphinxAtStartPar
si \(A = [ ]\), on retourne l’arbre \(((k,u),[],[])\) ;

\item {} 
\sphinxAtStartPar
si \(A = [(c,v),Fg,Fd]\) alors :
\begin{itemize}
\item {} 
\sphinxAtStartPar
si \(c = k\) on remplace  le couple \((c,v)\)par \((k,u)\)et on insère \((c,v)\)dans \(Fg\)ou \(Fd\);

\item {} 
\sphinxAtStartPar
si \(c > k\) on insère \((k,u)\) dans \(Fg\);

\item {} 
\sphinxAtStartPar
si \(c < k\) on insère \((k,u)\) dans \(Fd\)

\end{itemize}

\end{itemize}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{insertion\PYGZus{}feuille}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{paire}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{A}\PYG{o}{==}\PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
        \PYG{n}{A}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{p}{[}\PYG{n}{paire}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{paire}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{:}
        \PYG{n}{insertion\PYGZus{}feuille}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{paire}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{insertion\PYGZus{}feuille}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{paire}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{remplire}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{L}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{paire} \PYG{o+ow}{in} \PYG{n}{L}\PYG{p}{:}
        \PYG{n}{insertion\PYGZus{}feuille}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{paire}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{initialiser}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{c+c1}{\PYGZsh{}Pour avoir les meme valeurs aleatoires}
    \PYG{n}{L}\PYG{o}{=}\PYG{p}{[}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{L}\PYG{o}{=}\PYG{p}{[}\PYG{p}{(}\PYG{n}{e}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}\PYG{p}{)} \PYG{k}{for} \PYG{n}{e} \PYG{o+ow}{in} \PYG{n}{L}\PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{}print(\PYGZdq{}\PYGZhy{}\PYGZhy{}\PYGZgt{}\PYGZdq{}.join([str(p) for p in  L]))}
    \PYG{n}{A}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{}Initialisation par liste vide.}
    \PYG{n}{remplire}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{L}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}print(L)}
    \PYG{k}{return} \PYG{n}{A}\PYG{p}{,}\PYG{n}{L}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{p}{,}\PYG{n}{L}\PYG{o}{=}\PYG{n}{initialiser}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[(12, \PYGZsq{}v12\PYGZsq{}), [(1, \PYGZsq{}v1\PYGZsq{}), [], [(8, \PYGZsq{}v8\PYGZsq{}), [], [(12, \PYGZsq{}v12\PYGZsq{}), [(9, \PYGZsq{}v9\PYGZsq{}), [], []], []]]], [(13, \PYGZsq{}v13\PYGZsq{}), [], [(16, \PYGZsq{}v16\PYGZsq{}), [(15, \PYGZsq{}v15\PYGZsq{}), [], []], []]]]
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}

\sphinxAtStartPar
Cette fonction d’insertion à un coût en \(O(h(A))\).


\subsection{Suppression}
\label{\detokenize{notebooks/ABR/ABR:suppression}}

\subsubsection{Supprission de la valeur minimale}
\label{\detokenize{notebooks/ABR/ABR:supprission-de-la-valeur-minimale}}
\sphinxAtStartPar
Nous aurons besoin d’une fonction qui prend en argument un arbre \(A\) et retourne le couple \((m;A')\) formé d’un élément m de clé minimale et de l’arbre \(A' = A\backslash  \{m\}\) :
\begin{itemize}
\item {} 
\sphinxAtStartPar
Si A={[} {]}: Alors rien à supprimer

\item {} 
\sphinxAtStartPar
Si Fg={[} {]} alors supprimer la racine et remplacer l’arbre A par Fd.

\item {} 
\sphinxAtStartPar
Sinon supprimer le couple minimale à partir de l’arbre gauche.

\end{itemize}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{supprime\PYGZus{}min}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{A}\PYG{o}{==}\PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
        \PYG{k}{return} \PYG{k+kc}{None}
    \PYG{k}{if} \PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{==}\PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
        \PYG{n}{droped}\PYG{o}{=}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{A}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}\PYG{o}{=}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
        \PYG{k}{return} \PYG{n}{droped}
    \PYG{k}{return} \PYG{n}{supprime\PYGZus{}min}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}

\sphinxAtStartPar
La suppression d’une clé \(k\) dans un arbre binaire de recherche consiste à supprimer le couple \((k;v)\) situé à la profondeur minimale dans l’arbre \(A = [(c;v);Fg;Fd].\) On procède ainsi :
\begin{itemize}
\item {} 
\sphinxAtStartPar
si \(k < c\), on supprime un élément de clé k dans Fg ;

\item {} 
\sphinxAtStartPar
si \(k > c\), on supprime un élément de clé k dans Fd ;

\item {} 
\sphinxAtStartPar
si \(k = c\), alors :
\begin{itemize}
\item {} 
\sphinxAtStartPar
si \(Fg = [ ]\) on renvoie \(Fd\) ;

\item {} 
\sphinxAtStartPar
si \(Fd = [ ]\) on renvoie \(Fg\) ;

\item {} 
\sphinxAtStartPar
sinon, on supprime de \(Fd\) un élément \(m\) de clé minimale pour obtenir \(Fd'\) et on retourne {[}m, Fg, Fd’ {]}.

\end{itemize}

\end{itemize}

\sphinxAtStartPar
La suppression d’une clé k se réalise alors ainsi :
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{supprimer}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{A}\PYG{o}{==}\PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
        \PYG{k}{return} \PYG{k+kc}{None}
    \PYG{k}{if} \PYG{n}{k}\PYG{o}{\PYGZlt{}}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{supprimer}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{k}\PYG{o}{\PYGZgt{}}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{supprimer}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}
    
    \PYG{k}{if} \PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{==}\PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
        \PYG{n}{dropped}\PYG{p}{,}\PYG{n}{A}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}\PYG{o}{=}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
        \PYG{k}{return} \PYG{n}{dropped}
    \PYG{k}{if} \PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{==}\PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
        \PYG{n}{dropped}\PYG{p}{,}\PYG{n}{A}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}\PYG{o}{=}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{k}{return} \PYG{n}{dropped}
    \PYG{n}{m}\PYG{o}{=}\PYG{n}{supprime\PYGZus{}min}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{A}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}\PYG{o}{=}\PYG{p}{[}\PYG{n}{m}\PYG{p}{,}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{p}{,}\PYG{n}{\PYGZus{}}\PYG{o}{=}\PYG{n}{initialiser}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[(12, \PYGZsq{}v12\PYGZsq{}), [(1, \PYGZsq{}v1\PYGZsq{}), [], [(8, \PYGZsq{}v8\PYGZsq{}), [], [(12, \PYGZsq{}v12\PYGZsq{}), [(9, \PYGZsq{}v9\PYGZsq{}), [], []], []]]], [(13, \PYGZsq{}v13\PYGZsq{}), [], [(16, \PYGZsq{}v16\PYGZsq{}), [(15, \PYGZsq{}v15\PYGZsq{}), [], []], []]]]
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{supprimer}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[(12, \PYGZsq{}v12\PYGZsq{}), [(1, \PYGZsq{}v1\PYGZsq{}), [], [(12, \PYGZsq{}v12\PYGZsq{}), [(9, \PYGZsq{}v9\PYGZsq{}), [], []], []]], [(13, \PYGZsq{}v13\PYGZsq{}), [], [(16, \PYGZsq{}v16\PYGZsq{}), [(15, \PYGZsq{}v15\PYGZsq{}), [], []], []]]]
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}

\sphinxAtStartPar
La fonction de suppression a elle aussi un coût temporel en \(O(h(A))\) puisque chaque appel récursif s’effectue sur un arbre de hauteur inférieur au précédent.


\section{Requêtes dans un arbre binaire de recherche}
\label{\detokenize{notebooks/ABR/ABR:requetes-dans-un-arbre-binaire-de-recherche}}

\subsection{Recherche d’une clé}
\label{\detokenize{notebooks/ABR/ABR:recherche-dune-cle}}
\sphinxAtStartPar
Une des opérations les plus courantes dans un arbre binaire de recherche \(A\) = \([Fg;(c;v);Fd]\) est la recherche
d’une valeur associée à une clé particulière \(k\).
La démarche est évidente :
\begin{itemize}
\item {} 
\sphinxAtStartPar
si \(k = c\), retourner \(v\) ;

\item {} 
\sphinxAtStartPar
si \(k < c\), rechercher \(k\) dans \(Fg\) ;

\item {} 
\sphinxAtStartPar
si \(k > c\), rechercher \(k\) dans \(Fd\).

\end{itemize}

\sphinxAtStartPar
Dans le cas où les clés ne sont pas toutes distinctes on retournera la valeur associée à la première clé égale à \(k\) rencontrée.
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{recherche}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{A}\PYG{p}{,}\PYG{n}{k}\PYG{p}{:} \PYG{k+kc}{None} \PYG{k}{if} \PYG{n}{A}\PYG{o}{==}\PYG{p}{[}\PYG{p}{]} \PYG{k}{else}  \PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{k}{if} \PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{==}\PYG{n}{k} \PYG{k}{else} \PYG{n}{recherche}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)} \PYG{k}{if} \PYG{n}{k}\PYG{o}{\PYGZlt{}}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{k}{else} \PYG{n}{recherche}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{recherche}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}v12\PYGZsq{}
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}


\subsection{2.1 Recherche de la clé minimale / maximale}
\label{\detokenize{notebooks/ABR/ABR:recherche-de-la-cle-minimale-maximale}}
\sphinxAtStartPar
La recherche de la valeur associée à la clé minimale se poursuit dans le fils gauche tant que ce dernier n’est pas
vide :
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{np}\PYG{o}{.}\PYG{n}{inf}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{recherche\PYGZus{}min}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{A}\PYG{o}{==}\PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{}return (+infinie,\PYGZdq{}no min\PYGZdq{}) si l\PYGZsq{}arbre est vide}
        \PYG{k}{return} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{infty}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no min}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}sinon poursivie la recherche dans le sous arbre gauche}
    \PYG{n}{min\PYGZus{}g}\PYG{o}{=}\PYG{n}{recherche\PYGZus{}min}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{n}{min\PYGZus{}g}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{min\PYGZus{}g}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{p}{,}\PYG{n}{\PYGZus{}}\PYG{o}{=}\PYG{n}{initialiser}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{recherche\PYGZus{}min}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(1, \PYGZsq{}v1\PYGZsq{})
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}

\sphinxAtStartPar
La fonction retournant la valeur associée à la clé maximale est symétrique :
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{infty}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
float
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{recherche\PYGZus{}max}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{A}\PYG{o}{==}\PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{}return (\PYGZhy{}infinie,\PYGZdq{}no max\PYGZdq{}) si l\PYGZsq{}arbre est vide}
        \PYG{k}{return} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{infty}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no max}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}sinon poursivie la recherche dans le sous arbre droit}
    \PYG{n}{max\PYGZus{}d}\PYG{o}{=}\PYG{n}{recherche\PYGZus{}max}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{max\PYGZus{}d}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{max\PYGZus{}d}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{recherche\PYGZus{}max}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(16, \PYGZsq{}v16\PYGZsq{})
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}


\subsection{Recherche du prédécesseur / successeur}
\label{\detokenize{notebooks/ABR/ABR:recherche-du-predecesseur-successeur}}
\sphinxAtStartPar
\(k\in C\) étant donné, il s’agit cette fois de retourner la valeur associée à la plus grande des clés c contenues dans l’arbre et vérifiant :  \( c < k\) (respectivement \(c > k\))
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{prédécesseur}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{A}\PYG{o}{==}\PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
        \PYG{k}{return} \PYG{k+kc}{None}
    \PYG{k}{if} \PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{n}{k}\PYG{p}{:}
        \PYG{n}{pred}\PYG{o}{=}\PYG{n}{prédécesseur}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{k}{if} \PYG{n}{pred} \PYG{o}{==} \PYG{k+kc}{None} \PYG{k}{else} \PYG{n}{pred}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{prédécesseur}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{prédécesseur de: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{e} \PYG{o+ow}{in} \PYG{n}{L}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{ \PYGZlt{} }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{prédécesseur}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
prédécesseur de: 
	v9 \PYGZlt{} v12
	v12 \PYGZlt{} v13
	None \PYGZlt{} v1
	v1 \PYGZlt{} v8
	v15 \PYGZlt{} v16
	v13 \PYGZlt{} v15
	v9 \PYGZlt{} v12
	v8 \PYGZlt{} v9
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{successeur}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{A}\PYG{o}{==}\PYG{p}{[}\PYG{p}{]}\PYG{p}{:}
        \PYG{k}{return} \PYG{k+kc}{None}
    \PYG{k}{if} \PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZgt{}}\PYG{n}{k}\PYG{p}{:}
        \PYG{n}{succ}\PYG{o}{=}\PYG{n}{successeur}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{k}{if} \PYG{n}{succ} \PYG{o+ow}{is} \PYG{k+kc}{None} \PYG{k}{else} \PYG{n}{succ}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{successeur}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{prédécesseur | clé | successeur }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{e} \PYG{o+ow}{in} \PYG{n}{L}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{ \PYGZlt{} }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZlt{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{prédécesseur}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{successeur}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
prédécesseur | clé | successeur 
	v9 \PYGZlt{} v12\PYGZlt{}v13
	v12 \PYGZlt{} v13\PYGZlt{}v15
	None \PYGZlt{} v1\PYGZlt{}v8
	v1 \PYGZlt{} v8\PYGZlt{}v9
	v15 \PYGZlt{} v16\PYGZlt{}None
	v13 \PYGZlt{} v15\PYGZlt{}v16
	v9 \PYGZlt{} v12\PYGZlt{}v13
	v8 \PYGZlt{} v9\PYGZlt{}v12
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}


\subsection{Complexité temporelle}
\label{\detokenize{notebooks/ABR/ABR:complexite-temporelle}}
\sphinxAtStartPar
Toutes ces fonctions ont à l’évidence un coût temporel en \(O(h(A))\), ce qui explique tout l’intérêt qu’il peut y avoir à ce que l’arbre binaire de recherche soit équilibré : dans un arbre binaire quelconque d’ordre \(n = taille(A)\), on peut affirmer que le coût d’une requête est un \(O(n)\) ; dans le cas d’un arbre de recherche équilibré, on peut assurer un coût en \(O(log(n))\)


\chapter{Programmation dynamique}
\label{\detokenize{notebooks/dynamicProgramming/ProgrammationDynamique:programmation-dynamique}}\label{\detokenize{notebooks/dynamicProgramming/ProgrammationDynamique::doc}}

\section{Introduction}
\label{\detokenize{notebooks/dynamicProgramming/ProgrammationDynamique:introduction}}\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{mesurer} \PYG{k+kn}{import} \PYG{n}{mesure}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}cette fonction permet de mesurer le temps d\PYGZsq{}exécution d\PYGZsq{}une autre fonction}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}


\subsection{Un inconvénient de la programmation récursive}
\label{\detokenize{notebooks/dynamicProgramming/ProgrammationDynamique:un-inconvenient-de-la-programmation-recursive}}
\sphinxAtStartPar
Nous allons nous intéresser au calcul du coefficient binomial \(C^p_n=\binom{n}{p}\) Une solution consiste à utiliser la programmation récursive et la formule de Pascal, ce qui nous amène à écrire :
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{binom}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{p} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{o+ow}{or} \PYG{n}{n} \PYG{o}{==} \PYG{n}{p}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+m+mi}{1}
    \PYG{k}{return} \PYG{n}{binom}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n}{binom}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mesure}\PYG{p}{(}\PYG{n}{binom}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Temps d\PYGZsq{}execution :62.49358534812927 secondes 
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
155117520
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}

\sphinxAtStartPar
Malheureusement, cette fonction s’avère très peu efficace, même pour de relativement faibles valeurs de n et p : à titre d’illustration, il faut 42 secondes à mon ordinateur pour calculer  binom(30,15),

\sphinxAtStartPar
La raison en est facile à comprendre : lorsqu’on observe par exemple l’arbre de calcul de \(\binom{5}{2}\) on constate qu’il ya des appels récursifs sont identiques et donc superflus (figure 1).

\sphinxAtStartPar
Nous pouvons par exemple constater que le calcul de \(\binom{5}{2}\) nécessite de calculer trois \(\binom{2}{1}\) Et l’expérience montre que le calcul de \(\binom{30}{15}\), fait appel 40 116 600 au calcul de \(\binom{2}{1}\).

\sphinxAtStartPar
\sphinxincludegraphics{{binom}.png}


\section{Où est le problème ?}
\label{\detokenize{notebooks/dynamicProgramming/ProgrammationDynamique:ou-est-le-probleme}}
\sphinxAtStartPar
Le problème à résoudre, ici le calcul de \(\binom{n}{p}\), se ramène à la résolution de deux sous\sphinxhyphen{}problèmes : le calcul de \(\binom{n-1}{p-1}\) et de \(\binom{n-1}{p-1}\), sous\sphinxhyphen{}problèmes qui sont en interaction.

\sphinxAtStartPar
Par exemple, on constate sur la figure 1 que le calcul de \(\binom{4}{1}\) et le calcul de \(\binom{4}{2}\) font tous deux appel au même sous\sphinxhyphen{}problème : le calcul de \(\binom{3}{1}\).

\sphinxAtStartPar
Ainsi, la présence de sous\sphinxhyphen{}problèmes en interaction peut faire croitre très rapidement la complexité d’une
fonction, au point d’en rendre son usage rédhibitoire.

\sphinxAtStartPar
Tout comme les problèmes que l’on résout par une méthode « diviser pour régner », les problèmes que l’on
résout par la programmation dynamique se ramènent à la résolution de sous\sphinxhyphen{}problèmes de tailles inférieures.

\sphinxAtStartPar
Mais à la différence de la méthode « diviser pour régner », ces sous\sphinxhyphen{}problèmes ne sont pas indépendants, ce
qui impose d’accompagner la programmation récursive par une analyse fine des relations de dépendance, ou
beaucoup plus simplement par l’utilisation de la mémoïsation qui gère les relations de dépendance à notre
place.


\section{Une solution proposée par la programmation dynamique de type (Bottom UP)}
\label{\detokenize{notebooks/dynamicProgramming/ProgrammationDynamique:une-solution-proposee-par-la-programmation-dynamique-de-type-bottom-up}}
\sphinxAtStartPar
La solution proposée par la programmation dynamique consiste à commencer par résoudre les plus petits des sous\sphinxhyphen{}problèmes, puis de combiner leurs solutions pour résoudre des sous\sphinxhyphen{}problèmes de plus en plus grands.

\sphinxAtStartPar
La solution proposée par la programmation dynamique consiste à commencer par résoudre les plus petits des
sous\sphinxhyphen{}problèmes, puis de combiner leurs solutions pour résoudre des sous\sphinxhyphen{}problèmes de plus en plus grands.

\sphinxAtStartPar
Concrètement, le calcul de \(\binom{5 }{2}\) se réalise en suivant le schéma :
\sphinxincludegraphics{{bin5}.png}

\sphinxAtStartPar
Pour réaliser ce type de solution on utilise souvent un tableau, ici un tableau bi\sphinxhyphen{}dimensionnel \((n + 1) \times (p + 1)\) (dont seule la partie pour laquelle \(i > j\) sera utilisée).

\sphinxAtStartPar
Ce tableau sera progressivement rempli par les valeurs des coefficients binomiaux, en commençant par les plus petits: \sphinxincludegraphics{{bintable}.png}

\sphinxAtStartPar
Il faut faire attention à bien respecter la relation de dépendance (modélisée par les flèches
sur le schéma ci\sphinxhyphen{}dessus)
pour remplir les cases de ce tableau : la case destinée à recevoir la valeur de \(\binom{i}{j}\) ne peut être remplie qu’après les cases destinées à recevoi \(\binom{i-1}{j-1}\) et \(\binom{i-1}{j}\)
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{binom\PYGZus{}bottom\PYGZus{}up}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)}\PYG{p}{:} 
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{} Algorithme itératif avec list}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{p} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{int64}\PYG{p}{)} 
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{n} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:} 
        \PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{p} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{n} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{t}\PYG{p}{[}\PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{n}{t}\PYG{p}{[}\PYG{n}{i} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}

\sphinxAtStartPar
Au prix d’un coût spatial (la création du tableau) cet algorithme est bien plus efficient que l’algorithme récursif initial puisque sa complexité temporelle et spatiale est maintenant en O(np).
Remarque. Notons que cette solution n’est pas encore optimale : il est facile de constater sur le schéma de dépendance que l’algorithme ci\sphinxhyphen{}dessus remplit des cases inutiles pour le calcul de \(\binom{n}  {p}\)  : seules celles qui sont colorées sont nécessaires.

\sphinxAtStartPar
Un autre inconvénient, plus important celui\sphinxhyphen{}là réside dans la perte de lisibilité de l’algorithme, comparativement à l’algorithme récursif. L’idéal serait donc de combiner l’élégance de la programmation récursive avec l’efficacité de la programmation dynamique.


\section{Une solution proposée par la programmation dynamique de type (Top Down)}
\label{\detokenize{notebooks/dynamicProgramming/ProgrammationDynamique:une-solution-proposee-par-la-programmation-dynamique-de-type-top-down}}
\sphinxAtStartPar
La solution existe, elle porte le nom de mémoïsation.

\sphinxAtStartPar
Elle consiste à associer à la fonction un dictionnaire qui va mémoriser le résultat du calcul réalisé. Ainsi, à chaque fois que le programme aura besoin de calculer une valeur, il ira voir dans le dictionnaire si la valeur dont il a besoin a déjà été calculée, et ne réalisera le calcul que dans le cas contraire, en ajoutant ensuite la nouvelle valeur calculée au dictionnaire.

\sphinxAtStartPar
Le calcul du coefficient binomial va alors prendre la forme qui suit :
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{binom\PYGZus{}dict} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{def} \PYG{n+nf}{binom\PYGZus{}top\PYGZus{}down}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)}\PYG{p}{:} 
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{binom\PYGZus{}dict}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{p} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{o+ow}{or} \PYG{n}{n} \PYG{o}{==} \PYG{n}{p}\PYG{p}{:}
            \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{b} \PYG{o}{=} \PYG{n}{binom\PYGZus{}top\PYGZus{}down}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{p} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n}{binom\PYGZus{}top\PYGZus{}down}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)}
        \PYG{n}{binom\PYGZus{}dict}\PYG{p}{[}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{n}{b}
    \PYG{k}{return} \PYG{n}{binom\PYGZus{}dict}\PYG{p}{[}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}

\sphinxAtStartPar
On peut observer
que le programme récursif se retrouve presque mot pour mot lignes 5 à 8. !
Calculons \(\binom{5}{2}\) avec cette fonction, puis observons le contenu du dictionnaire :
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{binom\PYGZus{}top\PYGZus{}down}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
10
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{binom\PYGZus{}dict}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}(3, 0): 1, (2, 0): 1, (1, 0): 1, (1, 1): 1, (2, 1): 2, (3, 1): 3, (4, 1): 4, (2, 2): 1, (3, 2): 3, (4, 2): 6, (5, 2): 10\PYGZcb{}
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}

\sphinxAtStartPar
On peut constater qu’on y retrouve les 10 valeurs nécessaires pour réaliser ce calcul. J’ai représenté figure suivante  l’ordre dans lequel ces valeurs ont été introduites dans le dictionnaire.
\sphinxincludegraphics{{order}.png}




\chapter{Programmation Dynamique et optimisation}
\label{\detokenize{notebooks/dynamicProgramming/ProgrammationDynamique:programmation-dynamique-et-optimisation}}
\sphinxAtStartPar
Un des principaux champs d’applications de la programmation dynamique est la résolution de problèmes d’optimisation. Il s’agit de problèmes dont chaque solution possède une valeur.

\sphinxAtStartPar
On cherche alors une solution de valeur optimale (minimale ou maximale).
Il existe de nombreuses techniques pour résoudre ce genre de problèmes et
la programmation dynamique en fait partie. Des méthodes gloutonnes peuvent également marcher.

\sphinxAtStartPar
Il est donc logique de se demander à quelles conditions doit\sphinxhyphen{}on utiliser la programmation dynamique pour résoudre un problème d’optimisation.

\sphinxAtStartPar
Il faut premièrement que l’ensemble des éléments constituant le problème soit discret et fini .
Par exemple pour la recherche de plus courts chemins, ces éléments sont les sommets du graphe et les arêtes les reliant entre eux.

\sphinxAtStartPar
Ensuite, une solution optimale au problème global doit induire des
\begin{itemize}
\item {} 
\sphinxAtStartPar
solutions optimales aux sous\sphinxhyphen{}problèmes.

\item {} 
\sphinxAtStartPar
Enfin, il est nécessaire que les sous\sphinxhyphen{}problèmes ne soient pas indépendants .

\end{itemize}


\section{Démarche de résoluton}
\label{\detokenize{notebooks/dynamicProgramming/ProgrammationDynamique:demarche-de-resoluton}}
\sphinxAtStartPar
On retrouvera généralement quatre étapes dans la conception d’une solution optimale en utilisant la technique de programmation dynamique :
\begin{itemize}
\item {} 
\sphinxAtStartPar
Caractériser la structure d’une solution optimale.

\item {} 
\sphinxAtStartPar
Défnir par récurrence la valeur d’une solution optimale.

\item {} 
\sphinxAtStartPar
Calculer la valeur d’une solution optimale par une méthode Top Down ou Bottom Up.

\item {} 
\sphinxAtStartPar
Construire la solution optimale .

\end{itemize}


\section{Exemple: Problème Sac à Dos.}
\label{\detokenize{notebooks/dynamicProgramming/ProgrammationDynamique:exemple-probleme-sac-a-dos}}
\sphinxAtStartPar
Le problème du Sac à Dos est un problème classique en informatique. Il modélise une situation analogue au remplissage d’un sac.

\sphinxAtStartPar
Une personne veut remplir un sac à dos ne pouvant pas supporter plus d’un certain poids \(W_{max}\in \mathbb{N}\), et elle dispose de n objets On note l’ensemble des objects par \(O = \{1, . . . , n\}\).

\sphinxAtStartPar
Chaque objet i a une valeur \(v_ i\) et un poids \(w_i\).

\sphinxAtStartPar
Le problème est de trouver un ensemble d’objets tels que:
\begin{itemize}
\item {} 
\sphinxAtStartPar
tous les objets de cet ensemble puissent être mis dans le sac.

\item {} 
\sphinxAtStartPar
la somme des valeurs de ces objets soit maximale.

\end{itemize}

\sphinxAtStartPar
Le problème d’optimisation correspond à trouver un sous\sphinxhyphen{}ensemble \(I\) de \(O\) d’objets dont le poids total est inférieure à \(W\) et dont la valeur totale \(\Sigma_{i\in I}v_i \)  soit maximum.
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}exemple}
\PYG{c+c1}{\PYGZsh{} La list des poids}
\PYG{n}{WL}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{}La list des valeurs}
\PYG{n}{VL}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{}le poids maximal}
\PYG{n}{Wmax}\PYG{o}{=}\PYG{l+m+mi}{15}
\PYG{c+c1}{\PYGZsh{}le nombre d\PYGZsq{}objets}
\PYG{n}{n}\PYG{o}{=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{WL}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{S}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{WL}\PYG{p}{,}\PYG{n}{VL}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{S}\PYG{p}{)}
\PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{S}\PYG{p}{,}\PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{e}\PYG{p}{:}\PYG{p}{(}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{/}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{reverse}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[(3, 4), (9, 2), (6, 10), (3, 9)]
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[(3, 9), (6, 10), (3, 4), (9, 2)]
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sacAdos\PYGZus{}naive}\PYG{p}{(}\PYG{n}{VL}\PYG{p}{,}\PYG{n}{WL}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{VL}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{:} 
        \PYG{k}{return} \PYG{l+m+mi}{0}
    \PYG{k}{if} \PYG{n}{Wmax}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+m+mi}{0}
    \PYG{n}{v}\PYG{p}{,}\PYG{n}{w}\PYG{o}{=}\PYG{n}{VL}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{WL}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{k}{if} \PYG{n}{w}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{Wmax}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{v}\PYG{o}{+}\PYG{n}{sacAdos\PYGZus{}naive}\PYG{p}{(}\PYG{n}{VL}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{WL}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{Wmax}\PYG{o}{\PYGZhy{}}\PYG{n}{w}\PYG{p}{)}\PYG{p}{,}\PYG{n}{sacAdos\PYGZus{}naive}\PYG{p}{(}\PYG{n}{VL}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{WL}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{sacAdos\PYGZus{}naive}\PYG{p}{(}\PYG{n}{VL}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{WL}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sacAdos\PYGZus{}naive2}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}La meme chose avec que la précident sauf on prend comme parametre le nombre d\PYGZsq{}elements de la list et non pas la list}
    \PYG{k}{if} \PYG{n}{k}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{:} 
        \PYG{k}{return} \PYG{l+m+mi}{0}
    \PYG{k}{if} \PYG{n}{Wmax}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+m+mi}{0}
    \PYG{n}{v}\PYG{p}{,}\PYG{n}{w}\PYG{o}{=}\PYG{n}{VL}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,}\PYG{n}{WL}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}
    \PYG{k}{if} \PYG{n}{w}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{Wmax}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{v}\PYG{o}{+}\PYG{n}{sacAdos\PYGZus{}naive2}\PYG{p}{(}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Wmax}\PYG{o}{\PYGZhy{}}\PYG{n}{w}\PYG{p}{)}\PYG{p}{,}\PYG{n}{sacAdos\PYGZus{}naive2}\PYG{p}{(}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{sacAdos\PYGZus{}naive2}\PYG{p}{(}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{le valeur maximal par la méthode naive est }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{sacAdos\PYGZus{}naive}\PYG{p}{(}\PYG{n}{VL}\PYG{p}{,}\PYG{n}{WL}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{le valeur maximal par la méthode naive est }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{sacAdos\PYGZus{}naive2}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
le valeur maximal par la méthode naive est  23
le valeur maximal par la méthode naive est  19
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}


\subsection{La solution dynamique avec la programmation dynamique par la méthode Bottom\_UP}
\label{\detokenize{notebooks/dynamicProgramming/ProgrammationDynamique:la-solution-dynamique-avec-la-programmation-dynamique-par-la-methode-bottom-up}}
\sphinxAtStartPar
Pour calculer cette valeur de façon dynamique, nous allons utiliser un tableau bi\sphinxhyphen{}dimensionnel de taille \((n + 1) × (W_{max} + 1)\) destiné à contenir les valeurs de \(f (k, w)\) pour \(k \in [0, n]\) et \(W \in [0, W_{max}]\).

\sphinxAtStartPar
Nous prendrons comme valeurs initiales f (0, W) = f (k, 0) = 0, et notre but est de calculer \(f(n, W_{max} )\).

\sphinxAtStartPar
Pour remplir ce tableau, il est primordial de respecter l’ordre de dépendance des cases de ce tableau : la case \(f (k, W)\) ne peut être calculée que lorsque les cases \(f (k-1, W)\) et \(f (k -1, W -w_k )\) auront été remplies.
\sphinxincludegraphics{{BUSac}.png}



\sphinxAtStartPar
En considérant que les valeurs \(c_k\) et \(w_k\) sont données sous forme de tableaux, on en déduit l’algorithme :
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k}{def} \PYG{n+nf}{sacAdos\PYGZus{}Bottom\PYGZus{}Up}\PYG{p}{(}\PYG{n}{WL}\PYG{p}{,}\PYG{n}{VL}\PYG{p}{,} \PYG{n}{Wmax}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n}\PYG{o}{=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{VL}\PYG{p}{)}
    \PYG{n}{f}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Wmax}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{w} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Wmax}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{WL}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{w}\PYG{p}{:}
                \PYG{n}{f}\PYG{p}{[}\PYG{n}{k}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{w}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{VL}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{+}\PYG{n}{f}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,}\PYG{n}{w}\PYG{o}{\PYGZhy{}}\PYG{n}{WL}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{f}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,}\PYG{n}{w}\PYG{p}{]}\PYG{p}{)}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{f}\PYG{p}{[}\PYG{n}{k}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{w}\PYG{p}{]}\PYG{o}{=}\PYG{n}{f}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,}\PYG{n}{w}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{f}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{}return f}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{le valeur maximal par la méthode bottom up (iteratif) est }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{sacAdos\PYGZus{}Bottom\PYGZus{}Up}\PYG{p}{(}\PYG{n}{WL}\PYG{p}{,}\PYG{n}{VL}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
le valeur maximal par la méthode bottom up (iteratif) est  23.0
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}

\sphinxAtStartPar
Remarque. Cet algorithme calcule la valeur maximale qui peut être emportée dans le sac, mais pas la façon d’y parvenir.

\sphinxAtStartPar
Pour la connaître il faut utiliser le tableau (ou le dictionnaire) calculé par la fonction précédente, et retrouver le chemin qui mène de la case initiale à la case finale.

\sphinxAtStartPar
Par exemple, si on modifie la fonction non récursive (la première) pour qu’elle renvoie le tableau f qui a été calculé au lieu de la valeur \(f[len(WL), Wmax]\) , le fonction qui détermine les objets à choisir s’écrira :
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sacAdos\PYGZus{}Bottom\PYGZus{}Up\PYGZus{}modifié}\PYG{p}{(}\PYG{n}{WL}\PYG{p}{,}\PYG{n}{VL}\PYG{p}{,} \PYG{n}{Wmax}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n}\PYG{o}{=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{VL}\PYG{p}{)}
    \PYG{n}{f}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Wmax}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{w} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Wmax}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{WL}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{w}\PYG{p}{:}
                \PYG{n}{f}\PYG{p}{[}\PYG{n}{k}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{w}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{VL}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{+}\PYG{n}{f}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,}\PYG{n}{w}\PYG{o}{\PYGZhy{}}\PYG{n}{WL}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{f}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,}\PYG{n}{w}\PYG{p}{]}\PYG{p}{)}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{f}\PYG{p}{[}\PYG{n}{k}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{w}\PYG{p}{]}\PYG{o}{=}\PYG{n}{f}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,}\PYG{n}{w}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{f}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{]}\PYG{p}{,}\PYG{n}{f}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{objetsAchoisir}\PYG{p}{(}\PYG{n}{VL}\PYG{p}{,} \PYG{n}{WL}\PYG{p}{,} \PYG{n}{Wmax}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{v}\PYG{p}{,}\PYG{n}{f} \PYG{o}{=} \PYG{n}{sacAdos\PYGZus{}Bottom\PYGZus{}Up\PYGZus{}modifié}\PYG{p}{(}\PYG{n}{VL}\PYG{p}{,} \PYG{n}{WL}\PYG{p}{,} \PYG{n}{Wmax}\PYG{p}{)}
    \PYG{n}{sac} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{k}\PYG{p}{,} \PYG{n}{W} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{VL}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Wmax}
    \PYG{k}{while} \PYG{n}{k} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{f}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,} \PYG{n}{W}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{f}\PYG{p}{[}\PYG{n}{k} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{W}\PYG{p}{]}\PYG{p}{:}
            \PYG{n}{sac}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{VL}\PYG{p}{[}\PYG{n}{k} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{WL}\PYG{p}{[}\PYG{n}{k} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{W} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{WL}\PYG{p}{[}\PYG{n}{k} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{n}{k} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{return} \PYG{n}{v}\PYG{p}{,}\PYG{n}{sac}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{objetsAchoisir}\PYG{p}{(}\PYG{n}{VL}\PYG{p}{,} \PYG{n}{WL}\PYG{p}{,} \PYG{n}{Wmax}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(15.0, [(10, 6), (2, 9)])
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}


\subsection{La solution dynamique avec la programmation dynamique par la méthode Top\_Down}
\label{\detokenize{notebooks/dynamicProgramming/ProgrammationDynamique:la-solution-dynamique-avec-la-programmation-dynamique-par-la-methode-top-down}}\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sacAdos\PYGZus{}TD}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{,}\PYG{n}{memo}\PYG{o}{=}\PYG{n+nb}{dict}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{k}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{)} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{memo}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{k}\PYG{o}{==}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:} 
            \PYG{n}{memo}\PYG{p}{[}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{)}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{0}
            \PYG{k}{return} \PYG{n}{memo}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{]}
        \PYG{k}{if} \PYG{n}{Wmax}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n}{memo}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{0}
            \PYG{k}{return} \PYG{n}{memo}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{]}
        \PYG{n}{v}\PYG{p}{,}\PYG{n}{w}\PYG{o}{=}\PYG{n}{VL}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,}\PYG{n}{WL}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}
        \PYG{k}{if} \PYG{n}{w}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{Wmax}\PYG{p}{:}
            \PYG{n}{memo}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{]}\PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{v}\PYG{o}{+}\PYG{n}{sacAdos\PYGZus{}TD}\PYG{p}{(}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Wmax}\PYG{o}{\PYGZhy{}}\PYG{n}{w}\PYG{p}{,}\PYG{n}{memo}\PYG{p}{)}\PYG{p}{,}\PYG{n}{sacAdos\PYGZus{}TD}\PYG{p}{(}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{,}\PYG{n}{memo}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{memo}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{]}\PYG{o}{=}\PYG{n}{sacAdos\PYGZus{}TD}\PYG{p}{(}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{,}\PYG{n}{memo}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{memo}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{]}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sacAdos\PYGZus{}TD}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
23
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}


\subsection{La solution linéaire avec la programmation gloutoune}
\label{\detokenize{notebooks/dynamicProgramming/ProgrammationDynamique:la-solution-lineaire-avec-la-programmation-gloutoune}}
\sphinxAtStartPar
\sphinxincludegraphics{{glouton}.png}



\sphinxAtStartPar
Pour élaborer un algorithme glouton résolvant le problème, il faut définir une heuristique, ici un critère de
priorité pour le choix des objets à prendre.

\sphinxAtStartPar
Nous pouvons par exemple choisir en priorité les objets dont le rapport \( \frac{valeur}{poids}= \frac{v_i}{w_i}\) est maximal, et remplir le sac tant que c’est possible :
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sac\PYGZus{}à\PYGZus{}dos\PYGZus{}glouton}\PYG{p}{(}\PYG{n}{WL}\PYG{p}{,}\PYG{n}{VL}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{S}\PYG{o}{=}\PYG{n+nb}{sorted}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{n}{WL}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,}\PYG{n}{VL}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)} \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{WL}\PYG{p}{)}\PYG{p}{)} \PYG{p}{]}\PYG{p}{,}
    \PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{e}\PYG{p}{:}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{/}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{reverse}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{Sol}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
    \PYG{n}{w}\PYG{o}{=}\PYG{n}{Wmax}
    \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}
    \PYG{k}{for} \PYG{n}{o} \PYG{o+ow}{in} \PYG{n}{S}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{o}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{w}\PYG{p}{:}
            \PYG{n}{Sol}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{o}\PYG{p}{)}
            \PYG{n}{v}\PYG{o}{+}\PYG{o}{=}\PYG{n}{o}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
            \PYG{n}{w}\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{n}{o}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{v}\PYG{p}{,}\PYG{n}{Sol}
    \PYG{c+c1}{\PYGZsh{}return v}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sac\PYGZus{}à\PYGZus{}dos\PYGZus{}glouton}\PYG{p}{(}\PYG{n}{WL}\PYG{p}{,}\PYG{n}{VL}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(23, [(3, 9), (6, 10), (3, 4)])
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}

\sphinxAtStartPar
Cette fois l’algorithme heristique gloutoun donne la solution optimale, mais ce n’est pas le cas en général

\sphinxAtStartPar
Car il donne une solution qui est une proche mais non pas nécessairmet égal à la solution optimal.

\sphinxAtStartPar
Pour évaluer la qualité de cette heuristique, On réalis1000 expériences pour chacune desquelles On :
\begin{itemize}
\item {} 
\sphinxAtStartPar
pris au hasard 100 objets de valeurs comprises entre 1 et 20 et de poids compris entre 1 et 30 ;

\item {} 
\sphinxAtStartPar
calcul la valeur optimale obtenue pour un poids maximal égal à 300 à la fois par l’algorithme glouton
ci\sphinxhyphen{}dessus et par l’algorithme dynamique que nous étudierons plus loin.

\end{itemize}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{fiabilité}\PYG{p}{(}\PYG{n}{glouton}\PYG{p}{,}\PYG{n}{dynamique\PYGZus{}bu}\PYG{p}{,}\PYG{n}{samples}\PYG{p}{,}\PYG{n}{number\PYGZus{}of\PYGZus{}objects}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{VLL}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{p}{(}\PYG{n}{samples}\PYG{p}{,}\PYG{n}{number\PYGZus{}of\PYGZus{}objects}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{WLL}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{p}{(}\PYG{n}{samples}\PYG{p}{,}\PYG{n}{number\PYGZus{}of\PYGZus{}objects}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{Wmax}\PYG{o}{=}\PYG{l+m+mi}{300}
    \PYG{n}{glouton\PYGZus{}values}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
    \PYG{n}{dynamique\PYGZus{}values}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{samples}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{glouton\PYGZus{}values}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{glouton}\PYG{p}{(}\PYG{n}{WLL}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{VLL}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{Wmax}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{dynamique\PYGZus{}values}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{dynamique\PYGZus{}bu}\PYG{p}{(}\PYG{n}{WLL}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{VLL}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}  \PYG{n}{Wmax}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{glouton\PYGZus{}values}\PYG{p}{,}\PYG{n}{dynamique\PYGZus{}values}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{g}\PYG{p}{,}\PYG{n}{d}\PYG{o}{=}\PYG{n}{fiabilité}\PYG{p}{(}\PYG{n}{sac\PYGZus{}à\PYGZus{}dos\PYGZus{}glouton}\PYG{p}{,}\PYG{n}{sacAdos\PYGZus{}Bottom\PYGZus{}Up}\PYG{p}{,}\PYG{l+m+mi}{200}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}
\PYG{n}{g}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}
\PYG{n}{d}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}
\PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{g}\PYG{o}{\PYGZhy{}}\PYG{n}{d}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{o}{/}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
48.5
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fiab}\PYG{o}{=}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{g}\PYG{o}{\PYGZhy{}}\PYG{n}{d}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{grand\PYGZus{}écart}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,}\PYG{n}{d}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}l\PYGZsq{}equivalent au norm sup dans un evn}
    \PYG{n}{imax}\PYG{o}{=}\PYG{l+m+mi}{0}
    \PYG{n+nb}{max}\PYG{o}{=}\PYG{n}{d}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{g}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{ecart}\PYG{o}{=}\PYG{n}{d}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{g}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        \PYG{k}{if} \PYG{n+nb}{max}\PYG{o}{\PYGZlt{}}\PYG{n}{ecart}\PYG{p}{:}
            \PYG{n+nb}{max}\PYG{o}{=}\PYG{n}{ecart}
            \PYG{n}{imax}\PYG{o}{=}\PYG{n}{i}
    \PYG{k}{return} \PYG{n}{imax}
\PYG{n}{i}\PYG{o}{=}\PYG{n}{grand\PYGZus{}écart}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,}\PYG{n}{d}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{résultat}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s+s2}{Sur les 200 expériences, }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{ ont donné le même résultat pour chacun des deux algorithmes,}
\PYG{l+s+s2}{ et dans le cas des }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{ autres, l}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{algorithme glouton a toujours rendu un résultat au moins égal à }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+si}{\PYGZpc{} d}\PYG{l+s+s2}{u résultat de l}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{algorithme dynamique. }
\PYG{l+s+s2}{On peut donc considérer ici qu}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{à défaut de donner un résultat toujours exact, l}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{algorithme glouton donne un résultat acceptable tout en ayant une complexité moindre que l}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{algorithme dynamique.}
\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{fiab}\PYG{p}{,}\PYG{l+m+mi}{200}\PYG{o}{\PYGZhy{}}\PYG{n}{fiab}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{g}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{/}\PYG{n}{d}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{résultat}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Sur les 200 expériences, 97 ont donné le même résultat pour chacun des deux algorithmes,
 et dans le cas des 103 autres, l\PYGZsq{}algorithme glouton a toujours rendu un résultat au moins égal à 98\PYGZpc{} du résultat de l\PYGZsq{}algorithme dynamique. 
On peut donc considérer ici qu\PYGZsq{}à défaut de donner un résultat toujours exact, l\PYGZsq{}algorithme glouton donne un résultat acceptable tout en ayant une complexité moindre que l\PYGZsq{}algorithme dynamique.
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}


\chapter{Les algorithmes gloutons}
\label{\detokenize{notebooks/dynamicProgramming/glouton:les-algorithmes-gloutons}}\label{\detokenize{notebooks/dynamicProgramming/glouton::doc}}

\section{Introduction}
\label{\detokenize{notebooks/dynamicProgramming/glouton:introduction}}
\sphinxAtStartPar
La résolution d’un problème algorithmique peut parfois se faire à l’aide de techniques générales (« paradigmes ») qui ont pour avantage d’etre applicables à un grand nombre de situations.

\sphinxAtStartPar
Parmi ces méthodes on peut citer par exemple le fameux principe diviser pour régner ou encore la programmation dynamique.

\sphinxAtStartPar
Les algorithmes gloutons, que l’on rencontre principalement pour résoudre des
problèmes d’optimisation, constituent l’une de ces techniques générales de résolution.

\sphinxAtStartPar
Nous allons tout d’abord donner une définition intuitive de cette méthode, accompagnée de divers exemples.


\section{Définition: Algorithme Heuristiques :}
\label{\detokenize{notebooks/dynamicProgramming/glouton:definition-algorithme-heuristiques}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Méthode empiriques simples basées sur l’expérience (résultats déjà obtenus) et sur l’analogie.

\item {} 
\sphinxAtStartPar
Généralement, on n’obtient pas la solution optimale mais une solution approchée.

\end{itemize}


\section{Définition: Algorithme glouton}
\label{\detokenize{notebooks/dynamicProgramming/glouton:definition-algorithme-glouton}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Un algorithme glouton est un algorithme qui suit le principe de faire, étape par étape, un choix optimum local, dans l’espoir d’obtenir un résultat optimum global

\item {} 
\sphinxAtStartPar
Dans les cas où l’algorithme ne fournit pas systématiquement la solution optimale, il est appelé une heuristique gloutonne

\item {} 
\sphinxAtStartPar
La facon dont on fait le choix est parfois appelée stratégie gloutonne

\end{itemize}


\chapter{TRAITEMENT DES IMAGES}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:traitement-des-images}}\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES::doc}}

\section{Caractéristiques d’une image}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:caracteristiques-dune-image}}

\subsection{Les pixels}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:les-pixels}}
\sphinxAtStartPar
Une image est un ensemble de pixels qui peuvent être définis comme des zones carrées identiques de dimensions (L × C). La couleur de chaque pixel est uniforme et l’aspect non granulaire d’une image n’est dû qu’au fait que la taille des pixels est très petite.La figure ci\sphinxhyphen{}dessous donne un exemple d’image “binaire” représentant un A. Il n’y a ici que deux couleurs : noir et blanc.\sphinxincludegraphics{{A}.png}

\sphinxAtStartPar
Les images dites en « noir et blanc » sont en fait des images en dégradé de gris. Elles peuvent aussi être représentées par des matrices : chaque élément de la matrice correspondra comme précédemment à un pixel, mais ces éléments seront des nombres entiers donnant l’intensité de gris voulue. On utilise habituellement des nombres de 0 à 255, 0 pour le noir et 255 pour le blanc, soit \(256 = 2^8\) niveaux de gris, ce qui permet de coder un pixel par 8 bits.

\sphinxAtStartPar
Les images en couleur sont représentées par trois matrices de taille identique, donnant l’intensité de Rouge, Vert, et Bleu pour chaque pixel. Cette méthode est désignée par le sigle RGB (Red, Green, Blue).Les éléments de ces trois matrices sont encore des entiers de 0 à 255.
Dans le système RGB, il y a donc \(256^ 3 = 2^{24} = 16 777 216\) teintes possibles pour chaque pixel.L’image finale est obtenue en combinant les trois images. Ci\sphinxhyphen{}dessous le résultat final.\sphinxincludegraphics{{reign_pic_breakdown}.png}


\subsection{Le format RGB}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:le-format-rgb}}
\sphinxAtStartPar
Une norme fréquemment utilisée pour les images numériques est la norme RGB (Red Green Blue). Ce qu’on appelle un pixel d’écran est composé de trois leds des trois couleurs RGB. Un pixel informatique est alors représenté sous la forme de trois valeurs numériques comprises entre 0 et 255, 0 représentant la led éteinte, et 255 la led totalement allumée. Ainsi :
\begin{itemize}
\item {} 
\sphinxAtStartPar
la couleur rouge est représentée par (255,0,0) ;

\item {} 
\sphinxAtStartPar
la couleur verte est représentée par  (0,255,0);

\item {} 
\sphinxAtStartPar
la couleur bleue est représentée par (0,0,255) ;

\item {} 
\sphinxAtStartPar
la couleur fuchsia (violet) est représentée par (255,0,255) …

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{three_d_array}.png}


\subsection{Transparence et Canal Alpha}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:transparence-et-canal-alpha}}
\sphinxAtStartPar
Pour certains types d’images, un quatrième octet est utilisé pour chaque pixel. Il s’agit du canal alpha, qui caractérise la transparence de ce pixel. Cette couche supplémentaire permet de superposer des images \sphinxhyphen{} par exemple dans un jeu vidéo un sprite pourra apparaître sur le fond, sans masquer la totalité sous la forme d’un carré.

\sphinxAtStartPar
Cet octet supplémentaire est utilisé de la manière suivante :
\begin{itemize}
\item {} 
\sphinxAtStartPar
si il est à 255, le pixel est correctemnt affiché ;

\item {} 
\sphinxAtStartPar
si il est à 0, le pixel est transparent.

\end{itemize}

\sphinxAtStartPar
En informatique, une image en couleurs est constituée d’un ensemble de pixels colorés, arrangés en lignes et en colonnes. Chaque pixel est, généralement, constitué d’un mélange de trois couleurs : rouge, vert et bleu.\sphinxincludegraphics{{rgb_model}.png}


\subsection{Chargement de l’image}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:chargement-de-limage}}
\sphinxAtStartPar
Nous allons utiliser le module image de matplotlib

\sphinxAtStartPar
pour charger en mémoire une image.
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{image} \PYG{k}{as} \PYG{n+nn}{mpimg}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}

\sphinxAtStartPar
On peut procéder de la sorte pour charger une image en\sphinxhyphen{}nesyri.png qui se trouverait en répertoire local:
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{img} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imread}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pictures/en\PYGZhy{}nesyri.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}


\subsubsection{La taille de l’image}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:la-taille-de-l-image}}
\sphinxAtStartPar
Si, dans un algorithme, il est besoin de connaître la taille de l’image, on rappelle que image.shape fournit un tuple de trois éléments, conprenant la hauteur de l’image, sa largeur, et le nombre de canaux de couleur (3, en principe).
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(667, 1000, 3)
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}


\subsubsection{Affichage d’une image}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:affichage-dune-image}}
\sphinxAtStartPar
Pour afficher une image ayant trois canaux de couleur, il suffit de faire appel à plt.imshow:
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x7f1f01f2a3d0\PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_17_1}.png}
\end{sphinxVerbatimOutput}

\sphinxAtStartPar
Ainsi, vous avez vos données dans un tableau numpy (soit en l’important, soit en le générant).Affichons\sphinxhyphen{}le, Dans Matplotlib, cela est effectué à l’aide de la fonction imshow().Ici, nous allons saisir l’objet plot. Cet objet vous permet de manipuler facilement le tracé à partir de l’invite.

\sphinxAtStartPar
Python utilise un tableau à trois dimensions pour représenter l’image en couleur. Comme
pour une matrice, le premier indice désigne la ligne, la seconde la colonne. Le troisième
indice désigne le canal de couleur (dans l’ordre, rouge, vert et bleu).


\subsubsection{Recadrer l’image}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:recadrer-l-image}}
\sphinxAtStartPar
pour selectionner une partie spécifique en peut utiliser le slicing offert par les objets ndarray de numpy, ainsi ce code permet par exemple de selectionner la partie visage du joeur Youssef En\sphinxhyphen{}nesyri.
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{img}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{:}\PYG{l+m+mi}{400}\PYG{p}{,}\PYG{l+m+mi}{200}\PYG{p}{:}\PYG{l+m+mi}{600}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x7f1f00b25d60\PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_22_1}.png}
\end{sphinxVerbatimOutput}


\subsection{Modification d’une image}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:modification-dune-image}}
\sphinxAtStartPar
On peut modifier la valeur correspondant à l’intensité d’une couleur d’un pixel par mutation de la case correspondante du tableau, par exemple de la sorte :
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{img}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.2}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}

\sphinxAtStartPar
Cette commande attribue, pour le pixel situé sur la ligne d’index 4 (la cinquième ligne), dans la colonne d’index 11, une intensité égale à 0.2 pour le canal d’index 2 (le troisième canal de couleur, donc, correspondant au bleu).
désigne la couleur bleue du pixel situé à la cinquième ligne et à la douzième colonne (on rappelle que les indices débutent à 0).
Chacune des valeurs est un entier sur 8 bits, entre 0 et 1. 0 représente l’absence de la couleur concernée, 1 le maximum.\textbackslash{}
Si les trois valeurs de couleur sont à 0, on obtient du noir. Si elles sont toutes les trois à 1, du blanc.\textbackslash{} Pour obtenir du rouge, il faut une valeur 1 pour la valeur rouge, et 0 pour les deux autres.
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{img}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.9}\PYG{p}{,} \PYG{l+m+mf}{0.2}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}


\section{Traitements basiques de l’image}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:traitements-basiques-de-limage}}
\sphinxAtStartPar
Une petite fonction qui permet d’afficher deux images old et new
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{afficher\PYGZus{}changement}\PYG{p}{(}\PYG{n}{old}\PYG{p}{,}\PYG{n}{new}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{old}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{new}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}

\sphinxAtStartPar
Dans un premier temps, nous allons écrire quelques fonctions qui modifient une image, passée en argument de la fonction.Comme les listes, les numpy.array et donc les images sont des objets mutables, que l’on peut directement  modifier dans les fonctions.Les fonctions n’ont donc, en principe, pas besoin de retourner de résultat.


\subsection{Inversion}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:inversion}}
\sphinxAtStartPar
L’inversion d’une image consiste à remplacer, pour chaque pixel et pour chaque canal de couleur, une valeur v par \(1.0 − v\) (ou \(255 − v\) si l’on travaillait avec des valeurs entières).
Cela a pour effet de transformer le blanc en noir (et inversement), le rouge en cyan, le vert  en magenta, etc.

\sphinxAtStartPar
Écrire une fonction Inverse(img) qui prend en argument une image et l’inverse, et tester son bon fonctionnement.
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{inversion}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{image}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{image\PYGZus{}negatif}\PYG{o}{=}\PYG{n}{inversion}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}
\PYG{n}{negatif2}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones\PYGZus{}like}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{img}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{afficher\PYGZus{}changement}\PYG{p}{(}\PYG{n}{img}\PYG{p}{,}\PYG{n}{image\PYGZus{}negatif}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_35_0}.png}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{afficher\PYGZus{}changement}\PYG{p}{(}\PYG{n}{img}\PYG{p}{,}\PYG{n}{negatif2}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_36_0}.png}
\end{sphinxVerbatimOutput}


\subsubsection{Ajouter un réctangle}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:ajouter-un-rectangle}}\begin{itemize}
\item {} 
\sphinxAtStartPar
1.a Écrire une fonction AjouteRectangle(img) qui prend en argument une image, et modifie cette image de façon à ajouter sur celle\sphinxhyphen{}ci un rectangle vert de hauteur 80 et de largeur 160 dont le coin en haut à gauche se trouve à la ligne 50 et à la colonne 100.

\item {} 
\sphinxAtStartPar
1.b Charger une image, utiliser la fonction précédente, et afficher le résultat à l’écran.

\end{itemize}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{copy} \PYG{k+kn}{import} \PYG{n}{copy}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{border}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{newimage}\PYG{o}{=}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}
    \PYG{n}{n}\PYG{o}{=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}
    \PYG{n}{m}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{n}{n}\PYG{p}{)}
    \PYG{n}{blue}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{newimage}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{m}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{o}{=}\PYG{n}{blue}
    \PYG{n}{newimage}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{m}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{o}{=}\PYG{n}{blue}
    \PYG{n}{newimage}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{m}\PYG{p}{]}\PYG{o}{=}\PYG{n}{blue}
    \PYG{n}{newimage}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{m}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{n}{blue}
    \PYG{k}{return} \PYG{n}{newimage}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{imageborder}\PYG{o}{=}\PYG{n}{border}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}
\PYG{n}{afficher\PYGZus{}changement}\PYG{p}{(}\PYG{n}{img}\PYG{p}{,}\PYG{n}{imageborder}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_40_0}.png}
\end{sphinxVerbatimOutput}

\sphinxAtStartPar
Écrire une fonction AjouteDisque(img) qui prend en argument une image, et modifie cette image de façon a ajouter sur celle\sphinxhyphen{}ci un disque noire de rayon égale à la moitie de minimaum entre le nombre des lignes et le nombre des colones dont le centre se trouve au centre de l’image, puis tester son bon fonctionnement
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{norm2}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{i}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{j}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cercle}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,}\PYG{n}{ep}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{mx}\PYG{p}{,}\PYG{n}{my}\PYG{o}{=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}
    \PYG{n}{radious}\PYG{o}{=}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{mx}\PYG{p}{,}\PYG{n}{my}\PYG{p}{)}
    \PYG{n}{epaiseur}\PYG{o}{=}\PYG{n}{ep}\PYG{o}{*}\PYG{n}{radious}
    \PYG{n}{blue}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{200}\PYG{o}{/}\PYG{l+m+mi}{255}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{new\PYGZus{}image}\PYG{o}{=}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}
    \PYG{n}{masque}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{n}{norm2}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{mx}\PYG{p}{,}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{n}{my}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{n}{radious} \PYG{o+ow}{and} \PYG{n}{norm2}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{mx}\PYG{p}{,}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{n}{my}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{n}{radious}\PYG{o}{\PYGZhy{}}\PYG{n}{epaiseur} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{new\PYGZus{}image}\PYG{p}{[}\PYG{n}{masque}\PYG{p}{]}\PYG{o}{=}\PYG{n}{blue}
    \PYG{k}{return} \PYG{n}{new\PYGZus{}image}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{new\PYGZus{}image}\PYG{o}{=}\PYG{n}{cercle}\PYG{p}{(}\PYG{n}{img}\PYG{p}{,}\PYG{l+m+mf}{0.2}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{new\PYGZus{}image}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x7f1f00093340\PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_44_1}.png}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{afficher\PYGZus{}changement}\PYG{p}{(}\PYG{n}{img}\PYG{p}{,}\PYG{n}{new\PYGZus{}image}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_45_0}.png}
\end{sphinxVerbatimOutput}


\subsection{Retournement}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:retournement}}
\sphinxAtStartPar
Le retournement d’une image consiste à effectuer une symétrie autour de la ligne médiane de l’image.Les pixels de la dernière ligne se retrouvent sur la première ligne (et inversement), et ainsi de suite.
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{horizental\PYGZus{}sym}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{newimage}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{reversed}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{newimage}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hsym}\PYG{o}{=}\PYG{n}{horizental\PYGZus{}sym}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}
\PYG{n}{afficher\PYGZus{}changement}\PYG{p}{(}\PYG{n}{img}\PYG{p}{,}\PYG{n}{hsym}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_48_0}.png}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{retournemet}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n}\PYG{p}{,}\PYG{n}{\PYGZus{}}\PYG{p}{,}\PYG{n}{\PYGZus{}}\PYG{o}{=}\PYG{n}{image}\PYG{o}{.}\PYG{n}{shape}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{l1}\PYG{o}{=}\PYG{n}{image}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        \PYG{n}{image}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{image}\PYG{p}{[}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{}essayer d\PYGZsq{}enlever copy}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{img}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imread}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pictures/en\PYGZhy{}nesyri.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{retournemet}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x7f1f01ea4070\PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_52_1}.png}
\end{sphinxVerbatimOutput}


\subsubsection{Miroire}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:miroire}}
\sphinxAtStartPar
Ecrire une fonction Miroire(img) qui renvoie l’image miroire de img.
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{img}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imread}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pictures/en\PYGZhy{}nesyri.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{miroir}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n}{image}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mirror}\PYG{o}{=}\PYG{n}{miroir}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}
\PYG{n}{afficher\PYGZus{}changement}\PYG{p}{(}\PYG{n}{img}\PYG{p}{,}\PYG{n}{mirror}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_56_0}.png}
\end{sphinxVerbatimOutput}


\subsection{Passage en niveaux de gris}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:passage-en-niveaux-de-gris}}
\sphinxAtStartPar
Pour obtenir une image en niveaux de gris, c’est\sphinxhyphen{}à\sphinxhyphen{}dire dépourvue de couleur, il suffit que les valeurs des trois canaux de couleur de chaque pixel soient égales.Attention, cela reste une image en couleur, même si tous les pixels sont gris (on n’aura donc pas besoin de l’argument cmap=”gray” ici).

\sphinxAtStartPar
Pour convertir une image couleur en niveaux de gris, il faut donc remplacer les valeurs
des trois canaux par une unique valeur représentant la luminosité du pixel.

\sphinxAtStartPar
Il existe plusieurs façons de calculer cette valeur, selon l’image que l’on souhaite obtenir à l’arrivée. Lorsque l’on souhaite se rapprocher le plus possible de la vision humaine, on peut utiliser la formule suivante (qui privilégie le vert car c’est la couleur à laquelle notre œil est le plus sensible) :
\begin{equation*}
\begin{split}0.2126 × Rouge + 0.7152 × Vert + 0.0722 × Bleu\end{split}
\end{equation*}
\sphinxAtStartPar
On remarquera que la somme des trois coefficients est égale à 1.0, ce qui permet de
s’assurer que le résultat ne dépassera pas 1.0, et atteindra la valeur de 1.0 pour un pixel où les trois composantes de couleur égales à 1.0.

\sphinxAtStartPar
Écrire une fonction Monochrome(img) qui prend en argument une image en couleurs
et la transforme en une image en niveaux de gris selon la formule précédente, et vérifier
son bon fonctionnement.
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Monochrome}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{newimage}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{o}{*}\PYG{n}{image}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{0} \PYG{o}{*}\PYG{n}{image}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{o}{*}\PYG{n}{image}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{newimage}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{triplet}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{3} \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n}{l}\PYG{p}{]}\PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n}{image}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{image\PYGZus{}grise}\PYG{o}{=}\PYG{n}{triplet}\PYG{p}{(}\PYG{n}{Monochrome}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{afficher\PYGZus{}changement}\PYG{p}{(}\PYG{n}{img}\PYG{p}{,}\PYG{n}{image\PYGZus{}grise}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_61_0}.png}
\end{sphinxVerbatimOutput}


\subsubsection{Modification du contraste}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:modification-du-contraste}}
\sphinxAtStartPar
Certaines images peuvent être surexposées (trop claire, les valeurs des différents canaux de couleur étant toutes grandes), sous\sphinxhyphen{}exposée (même chose avec de petites valeurs), ou peu contrastée (toutes les valeurs sont proches).
Corriger le contraste d’une image consiste à modifier la répartition des valeurs entre 0.0 et 1.0 dans chacun des canaux. Cela consiste à appliquer, pour chaque canal de chaque pixel, une fonction définie de la sorte :
\begin{itemize}
\item {} 
\sphinxAtStartPar
si la valeur v est inférieure à vmin, on la remplace par 0.0 ;

\item {} 
\sphinxAtStartPar
si la valeur v est supérieure à vmax, on la remplace par 1.0 ;

\item {} 
\sphinxAtStartPar
sinon, on remplace la valeur v par (v − vmin)/(vmax − vmin).

\end{itemize}

\sphinxAtStartPar
On supposera, par simplicité, que l’on utilise la même formule pour chacun des trois canaux de couleurs et pour chacun des pixels. Il est fréquent d’utiliser des fonctions différentes pour chaque couleur, ce qui permet de corriger la teinte d’une image (par exemple une image rougie car prise sous un éclairage artificiel). Il arrive parfois que l’on utilise des fonctions différentes selon la zone de l’image, par exemple lorsque l’on veut obtenir un effet « HDR » (haute dynamique). Cela permet de ne pas avoir, sur une même image, des zones sous\sphinxhyphen{}exposées et des zones sur\sphinxhyphen{}exposées, ce qui est fréquemment le cas pour les images prises à l’extérieur.

\sphinxAtStartPar
Écrire une fonction AugmenteContraste(img, vmin, vmax) qui modifie le contraste d’une image, et vérifier son bon fonctionnement.On pourra choisir par exemple comme paramètres vmin = 0.2 et vmax = 0.8.
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{augmentContrast}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,}\PYG{n}{vmin} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{,}\PYG{n}{vmax} \PYG{o}{=} \PYG{l+m+mf}{0.8}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{k}{if} \PYG{n}{v}\PYG{o}{\PYGZlt{}}\PYG{n}{vmin} \PYG{k}{else} \PYG{l+m+mi}{1} \PYG{k}{if} \PYG{n}{v}\PYG{o}{\PYGZgt{}}\PYG{n}{vmax} \PYG{k}{else} \PYG{p}{(}\PYG{n}{v}\PYG{o}{\PYGZhy{}}\PYG{n}{vmin}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{vmax}\PYG{o}{\PYGZhy{}}\PYG{n}{vmin}\PYG{p}{)}  \PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{c}\PYG{p}{]} \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n}{l}\PYG{p}{]} \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n}{img}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{image\PYGZus{}contrast}\PYG{o}{=}\PYG{n}{augmentContrast}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}
\PYG{n}{afficher\PYGZus{}changement}\PYG{p}{(}\PYG{n}{img}\PYG{p}{,}\PYG{n}{image\PYGZus{}contrast}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_66_0}.png}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{red}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{newimage}\PYG{o}{=}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}
    \PYG{n}{newimage}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{0}
    \PYG{k}{return} \PYG{n}{newimage}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{redimage}\PYG{o}{=}\PYG{n}{red}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}
\PYG{n}{afficher\PYGZus{}changement}\PYG{p}{(}\PYG{n}{img}\PYG{p}{,}\PYG{n}{redimage}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_68_0}.png}
\end{sphinxVerbatimOutput}


\subsection{Histogramme d’une image}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:histogramme-dune-image}}
\sphinxAtStartPar
L’histogramme d’une image est le graphique qui représente le nombre de pixels existant pour chaque valeur. Calculer l’histogramme de l’image en niveaux de gris, c’est en d’autres termes compter combien il y a de pixels pour chaque nuance de gris.
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{histogram}\PYG{p}{(}\PYG{n}{image\PYGZus{}grise}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{histo}\PYG{o}{=}\PYG{n+nb}{dict}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n}{image\PYGZus{}grise}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n}{l}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{c} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{histo}\PYG{p}{:}
                \PYG{n}{histo}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{1}
            \PYG{k}{else}\PYG{p}{:}
                 \PYG{n}{histo}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
    \PYG{k}{return} \PYG{n}{histo}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{image2}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imread}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pictures/Lenna.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{image\PYGZus{}grise2}\PYG{o}{=}\PYG{n}{Monochrome}\PYG{p}{(}\PYG{n}{image2}\PYG{p}{)}
\PYG{n}{histo2}\PYG{o}{=}\PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{histogram}\PYG{p}{(}\PYG{n}{image\PYGZus{}grise2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pixels}\PYG{p}{,}\PYG{n}{occurences}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{histo2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{transpose}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{transp}\PYG{o}{=}\PYG{n}{image\PYGZus{}grise}\PYG{o}{.}\PYG{n}{transpose}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{pixels}\PYG{p}{,}\PYG{n}{occurences}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZlt{}matplotlib.lines.Line2D at 0x7f1f000d4670\PYGZgt{}]
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_73_1}.png}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gris}\PYG{o}{=}\PYG{n}{Monochrome}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}
\PYG{n}{histo1}\PYG{o}{=}\PYG{n}{histogram}\PYG{p}{(}\PYG{n}{gris}\PYG{p}{)}
\PYG{n}{histo1}\PYG{o}{=}\PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{histo1}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i}\PYG{p}{,}\PYG{n}{v}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{histo1}\PYG{p}{)}\PYG{o}{.}\PYG{n}{transpose}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZlt{}matplotlib.lines.Line2D at 0x7f1f001acb50\PYGZgt{}]
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_75_1}.png}
\end{sphinxVerbatimOutput}


\subsection{Seuillage fixe}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:seuillage-fixe}}
\sphinxAtStartPar
Le seuillage est un traitement qui permet de selectionner les informations significatives dans une image, ce traitement nécissite le réglage d’un seuil \sphinxstylestrong{S},
\begin{itemize}
\item {} 
\sphinxAtStartPar
Si la valeur d’un pixel Im{[}i,j{]} est inférieur au seuil S, alors la valeur de ce pixel est rémplacé  par 0

\item {} 
\sphinxAtStartPar
Sinon la valeur de ce pixel est remplacé par 1
Ainsi , on obtient une image en noir et blanc sans niveau de gris

\end{itemize}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{seuillage}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,}\PYG{n}{S}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{new\PYGZus{}image}\PYG{o}{=}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{new\PYGZus{}image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{new\PYGZus{}image}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{new\PYGZus{}image}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{k}{if} \PYG{n}{new\PYGZus{}image}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{n}{S} \PYG{k}{else} \PYG{l+m+mi}{1}
    \PYG{k}{return} \PYG{n}{new\PYGZus{}image}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{seuillé}\PYG{o}{=}\PYG{n}{triplet}\PYG{p}{(}\PYG{n}{seuillage}\PYG{p}{(}\PYG{n}{image\PYGZus{}grise}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{afficher\PYGZus{}changement}\PYG{p}{(}\PYG{n}{image\PYGZus{}grise}\PYG{p}{,}\PYG{n}{seuillé}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_79_0}.png}
\end{sphinxVerbatimOutput}


\subsection{Rotation d’images}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:rotation-d-images}}\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rotate}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,}\PYG{n}{angle}\PYG{o}{=}\PYG{l+m+mi}{90}\PYG{p}{,}\PYG{n}{centre}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{l}\PYG{p}{,}\PYG{n}{c}\PYG{p}{,}\PYG{n}{\PYGZus{}}\PYG{o}{=}\PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}
    \PYG{k}{if} \PYG{n}{centre}\PYG{o}{==}\PYG{k+kc}{None}\PYG{p}{:}
        \PYG{n}{centre}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{c}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{)}
    \PYG{n}{new\PYGZus{}coordinates}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{c}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{int}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{angle\PYGZus{}rad}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{deg2rad}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}
    \PYG{n}{rotation\PYGZus{}matrix}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{angle\PYGZus{}rad}\PYG{p}{)}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{angle\PYGZus{}rad}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{angle\PYGZus{}rad}\PYG{p}{)}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{angle\PYGZus{}rad}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{new\PYGZus{}coordinates}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{centre}\PYG{o}{+}\PYG{n}{rotation\PYGZus{}matrix}\PYG{o}{@}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{centre}\PYG{p}{)}
    \PYG{n}{m}\PYG{o}{=}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}
    \PYG{n}{new\PYGZus{}image}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{n}{m}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{ii}\PYG{p}{,}\PYG{n}{jj}\PYG{o}{=}\PYG{n}{new\PYGZus{}coordinates}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
            \PYG{n}{new\PYGZus{}image}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{,}\PYG{n}{jj}\PYG{p}{]}\PYG{o}{=}\PYG{n}{img}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{new\PYGZus{}image}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rotate\PYGZus{}image}\PYG{o}{=}\PYG{n}{rotate}\PYG{p}{(}\PYG{n}{img}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{90}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{afficher\PYGZus{}changement}\PYG{p}{(}\PYG{n}{img}\PYG{p}{,}\PYG{n}{rotate\PYGZus{}image}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_83_0}.png}
\end{sphinxVerbatimOutput}


\section{Application de filtres}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:application-de-filtres}}
\sphinxAtStartPar
\sphinxincludegraphics{{convolution}.png}

\sphinxAtStartPar
Un filtre, de manière générale, est une boîte noire qui transforme un signal d’entrée en un signal de sortie. Ce signal d’entrée peut être un signal ID (tension dépendant du temps), 2D (une image: la valeur du pixel dépend de sa position selon x et y) ou autre. Le signal peut être continu (ses valeurs sont repérées par un paramètre qui varie continûment, comme le temps, c’est le cas de la tension u(t) par exemple) ou discret (ses valeurs peuvent être dénombrées, c’est le cas d’un signal numérique).

\sphinxAtStartPar
Nous avons vu beaucoup de traitements qui s’appliquaient séparément sur chaques
pixels.Mais pour obtenir une gamme plus large d’effets, on peut envisager que les nouvelles couleurs d’un pixel dépendent non seulement des anciennes couleurs de ce pixel, mais
également des pixels voisins.

\sphinxAtStartPar
Dans cette situation, il n’est pas possible de modifier directement l’image (pourquoi ?)Il faut donc créer une nouvelle image vide, dont on pourra ensuite fixer la couleur de chaque pixel sans toucher à l’image originale.

\sphinxAtStartPar
Les fonctions suivantes vont donc retourner une nouvelle image qui sera le résultat du
calcul souhaité, au contraire des fonctions précédentes qui modifiaient leur argument.


\subsection{Flou ou Filtre moyenneur}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:flou-ou-filtre-moyenneur}}
\sphinxAtStartPar
Le filtre moyenneur est une opération de traitement d’images utilisée pour réduire le bruit dans une image et/ou flouter une image.

\sphinxAtStartPar
Le filtre moyenneur fait parti de la catégorie des filtres d’images locaux car pour calculer la nouvelle valeur d’un pixel, il regarde la valeur des pixels prochesConcrètement, la valeur filtrée d’un pixel p est égale à la moyenne des valeurs des pixels proches de p.En général, on définit les « pixels proches de p » comme l’ensemble de pixels contenus dans un carré de largeur k centré sur p :

\sphinxAtStartPar
Pour appliquer un flou à l’image, on remplace chaque couleur de chaque pixel par une
moyenne des couleurs des neufs pixels entourant le pixel considéré.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Écrire une fonction Floute(img) qui prend en entrée une image img et retourne
une nouvelle image correspondant à un flou de l’image originale, et vérifier son bon
fonctionnement. On réfléchira à ce qu’il est possible de faire sur les bords de l’image.

\end{enumerate}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vegeta\PYGZus{}image}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imread}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pictures/vegeta.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{flou}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{flou}\PYG{o}{=}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}\PYG{o}{+}\PYG{n}{image}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{image}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{+}\PYGZbs{}
    \PYG{n}{image}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}\PYG{o}{+}\PYG{n}{image}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{+}\PYGZbs{}
    \PYG{n}{image}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}\PYG{o}{+}\PYG{n}{image}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{image}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{9}
    \PYG{k}{return} \PYG{n}{flou}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{flou\PYGZus{}image}\PYG{o}{=}\PYG{n}{flou}\PYG{p}{(}\PYG{n}{vegeta\PYGZus{}image}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{afficher\PYGZus{}changement}\PYG{p}{(}\PYG{n}{vegeta\PYGZus{}image}\PYG{p}{,}\PYG{n}{flou\PYGZus{}image}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_95_0}.png}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{flou\PYGZus{}loops}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{newimage}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}
    \PYG{n}{l}\PYG{p}{,}\PYG{n}{c}\PYG{p}{,}\PYG{n}{\PYGZus{}}\PYG{o}{=}\PYG{n}{image}\PYG{o}{.}\PYG{n}{shape}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{l}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{newimage}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{image}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{+}\PYG{n}{image}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{image}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{image}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{image}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{image}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{+}\PYG{n}{image}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{9}
    \PYG{k}{return} \PYG{n}{newimage}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{image2\PYGZus{}flou}\PYG{o}{=}\PYG{n}{flou\PYGZus{}loops}\PYG{p}{(}\PYG{n}{vegeta\PYGZus{}image}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{afficher\PYGZus{}changement}\PYG{p}{(}\PYG{n}{vegeta\PYGZus{}image}\PYG{p}{,}\PYG{n}{image2\PYGZus{}flou}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_98_0}.png}
\end{sphinxVerbatimOutput}


\subsection{Détection de contours}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:detection-de-contours}}
\sphinxAtStartPar
Un contour, dans une image, est une zone de fortes variations des valeurs: si on pense à la
photographie d’un poster sombre sur un mur blanc, le contour sera l’endroit où l’on passe
du sombre au blanc. Détecter des contours est une opération importante, c’est la première étape vers des opérations de comptage automatisé, de reconnaissance de visages, etc. C’est une opération relativement compliquée dont nous allons voir ci\sphinxhyphen{}après quelques bases.

\sphinxAtStartPar
Il est possible de détecter les contours d’une image en déterminant, pour chaque pixel, la norme du gradient en ce point. En effet, un gradient élevé correspond à une brusque variation de la luminosité ou de la couleur, ce que l’on trouve en général au bord des objets.
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{convolution}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,}\PYG{n}{noyeau}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nl}\PYG{p}{,}\PYG{n}{nc}\PYG{o}{=}\PYG{n}{noyeau}\PYG{o}{.}\PYG{n}{shape}
    \PYG{n}{l}\PYG{p}{,}\PYG{n}{c}\PYG{o}{=}\PYG{n}{image}\PYG{o}{.}\PYG{n}{shape}
    \PYG{n}{image\PYGZus{}augmentée}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{l}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{c}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}augmentée}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{n}{image}
    \PYG{n}{newimage}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{newimage}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{noyeau}\PYG{o}{*}\PYG{n}{image\PYGZus{}augmentée}\PYG{p}{[}\PYG{n}{i}\PYG{p}{:}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{j}\PYG{p}{:}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{newimage}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}


\subsubsection{Concolution et filtre Moyenneur}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:concolution-et-filtre-moyenneur}}\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{moyenne}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{9}
\PYG{n}{gris}\PYG{o}{=}\PYG{n}{Monochrome}\PYG{p}{(}\PYG{n}{vegeta\PYGZus{}image}\PYG{p}{)}
\PYG{n}{fl}\PYG{o}{=}\PYG{n}{convolution}\PYG{p}{(}\PYG{n}{gris}\PYG{p}{,}\PYG{n}{moyenne}\PYG{p}{)}
\PYG{n}{fl}\PYG{o}{=}\PYG{n}{triplet}\PYG{p}{(}\PYG{n}{fl}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{fl}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x7f1f0029b8e0\PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_104_1}.png}
\end{sphinxVerbatimOutput}


\subsection{Détection des contours}
\label{\detokenize{notebooks/images/TRAITEMENT-DES-IMAGES:detection-des-contours}}\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gris}\PYG{o}{=}\PYG{n}{triplet}\PYG{p}{(}\PYG{n}{Monochrome}\PYG{p}{(}\PYG{n}{vegeta\PYGZus{}image}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{gris}\PYG{o}{=}\PYG{n}{gris}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{diff}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{fl}\PYG{o}{=}\PYG{n}{convolution}\PYG{p}{(}\PYG{n}{gris}\PYG{p}{,}\PYG{n}{diff}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{fl}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x7f1f000c95b0\PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_107_1}.png}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sobel}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{sbl}\PYG{o}{=}\PYG{n}{convolution}\PYG{p}{(}\PYG{n}{gris}\PYG{p}{,}\PYG{n}{sobel}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{sbl}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x7f1efaf4bfd0\PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_108_1}.png}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sobel2}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{sbl2}\PYG{o}{=}\PYG{n}{convolution}\PYG{p}{(}\PYG{n}{gris}\PYG{p}{,}\PYG{n}{sobel2}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{sbl2}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x7f1f0012e310\PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{TRAITEMENT-DES-IMAGES_109_1}.png}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k+kn}{import} \PYG{n}{Counter}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}https://www.youtube.com/watch?v=0p0o5cmgLdE}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}

\sphinxAtStartPar
Dans ce chapitre, on voit deux algorithmes pour l’intelligence artificielle : les k plus
proches voisins (KNN k nearest neighbors) et les k\sphinxhyphen{}moyennes (k means).


\chapter{Algorithme KNN: Cours}
\label{\detokenize{notebooks/Machine-Learning/KNN-Cours:algorithme-knn-cours}}\label{\detokenize{notebooks/Machine-Learning/KNN-Cours::doc}}

\section{Classification supervisée}
\label{\detokenize{notebooks/Machine-Learning/KNN-Cours:classification-supervisee}}\begin{itemize}
\item {} 
\sphinxAtStartPar
On considère le problème suivant : on dispose N objets sur lesquels on a mesuré différentes valeurs.Les mêmes mesures ont été faites sur chacun des objets.

\item {} 
\sphinxAtStartPar
La valeur de N est très grande.

\item {} 
\sphinxAtStartPar
Ces objets se répartissent selon T classes, avec T petit. On sait dans quel classe va chaque objet que l’on a mesuré.

\item {} 
\sphinxAtStartPar
Maintenant, on ajoute un nouvel objet sur lequel on a fait les mêmes mesures.

\item {} 
\sphinxAtStartPar
On souhaite lui associer une classe.

\item {} 
\sphinxAtStartPar
De quelle classe est\sphinxhyphen{}il le plus proche ?

\end{itemize}

\sphinxAtStartPar
On parle ainsi \sphinxstylestrong{D’APPRENTISSAGE SUPERVISÉ} . En effet, on apprend sur un jeu des données déjà classées comment classer les nouvelles données.

\sphinxAtStartPar
\sphinxstyleemphasis{Exemple 1.}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Ce type d’algorithme est très utilisé en intelligence artificielle particulièrement dans le commerce en ligne.

\item {} 
\sphinxAtStartPar
On a des informations sur N personnes (âge, sexe, habitude de navigation, etc.). On a classé leurs centres d’intérêts selon T types.

\item {} 
\sphinxAtStartPar
On peut alors proposer automatiquement à un nouvel individu des publicités adap\sphinxhyphen{}
tées en le classant automatiquement.

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{Exemple 2.}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Pour faire des diagnostics automatiques, On dispose de mesures médicales sur N individus pour lesquels on sait si il y a ou pas une tumeur cancéreuse, c’\sphinxhyphen{}à\sphinxhyphen{}d que l’on a répartis dans deux classes : malade / sain.

\item {} 
\sphinxAtStartPar
À partir de ces données, on peut déterminer automatiquement si un individu doit être considéré comme malade ou sain.

\end{itemize}


\section{La notion de distance:}
\label{\detokenize{notebooks/Machine-Learning/KNN-Cours:la-notion-de-distance}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Pour donner un sens à la classe la plus proche, cela suppose a minima de choisir une manière de mesurer les écarts entre les objets, c\sphinxhyphen{}à\sphinxhyphen{}d d’avoir une distance sur les mesures associées à aux objets.

\item {} 
\sphinxAtStartPar
Cela n’est pas du tout évident. D’autant plus que les mesures peuvent prendre
diverses formes.

\item {} 
\sphinxAtStartPar
Le choix de la distance est donc critique pour la classification.

\end{itemize}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{d1}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{:} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{p}{)} \PYG{k}{for} \PYG{n}{a}\PYG{p}{,}\PYG{n}{b} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{d2}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{a}\PYG{p}{,}\PYG{n}{b} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{d\PYGZus{}inf}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{:} \PYG{n+nb}{max}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{p}{)} \PYG{k}{for} \PYG{n}{a}\PYG{p}{,}\PYG{n}{b} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{d2\PYGZus{}np}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{p}{(}\PYG{n}{A}\PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{d1\PYGZus{}np}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{:} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{A}\PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{d\PYGZus{}inf\PYGZus{}np}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{:} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{A}\PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}


\section{Principe de l’algorithme}
\label{\detokenize{notebooks/Machine-Learning/KNN-Cours:principe-de-lalgorithme}}
\sphinxAtStartPar
\sphinxstylestrong{Mathématiquement},
\begin{itemize}
\item {} 
\sphinxAtStartPar
On dispose donc d’un ensemble \(E\) assez complexe (l’ensemble des mesures), \(E\) est muni d’une distance \(d\).

\item {} 
\sphinxAtStartPar
On dispose d’un ensemble C de classe de cardinal T .

\item {} 
\sphinxAtStartPar
On dispose donc de N éléments de \(E \times C\) (les mesures faites sur les objets et les classes associées). On les notes \((x_j , c_j)_{j\in [1, N]}\) .

\item {} 
\sphinxAtStartPar
Ainsi, \(x_j\) est la liste des mesures faites sur l’objet \(j\), et \(c_j\) la classe associée.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Problème} On considère de plus un élément y de E, non classé et on veut lui associer une classe.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Exemple :}
Comme problème jouet, on considère donc que \(E = \mathbb{R}^n\) et que l’on prend la distance
euclidienne.

\sphinxAtStartPar
L’algorithme des KNN consiste à :
\begin{itemize}
\item {} 
\sphinxAtStartPar
mesurer les distance \(d(y, x_j )\) pour \(j ∈ [|1, N|]\),

\item {} 
\sphinxAtStartPar
déterminer les k plus proches voisins de y. Les k éléments les plus proches de
y sont notés : \(x_{i_1} , x_{i_2} , . . . , x_{i_k}\) .

\item {} 
\sphinxAtStartPar
Choisir pour classe de y la classe la plus fréquente parmi celles de \((x_{i_1} , x_{i_2} , . . . , x_{i_k} )\)

\end{itemize}

\sphinxAtStartPar
Le choix du paramètre k (nombre de voisins que l’on prend en compte) est critique.Il n’est pas facile de régler ce paramètre et de l’interpréter.D’autre part, on peut avoir plusieurs classes avec le même effectif parmi les k voisins.Dans ce cas, l’algorithme ne permet pas de conclure et on attribue généralement arbitrairement une classe au nouvel objet y.


\section{Mise en place de chaque étape}
\label{\detokenize{notebooks/Machine-Learning/KNN-Cours:mise-en-place-de-chaque-etape}}

\subsection{Mesure des distances}
\label{\detokenize{notebooks/Machine-Learning/KNN-Cours:mesure-des-distances}}
\sphinxAtStartPar
On commence donc par créer une liste des distances : \(d(y, x_j )\) pour \(j \in [[1, N]]\).
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Distances}\PYG{p}{(}\PYG{n}{y} \PYG{p}{,}\PYG{n}{LearningData}\PYG{p}{,}\PYG{n}{d}\PYG{o}{=}\PYG{n}{d2}\PYG{p}{)} \PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    entrée :}
\PYG{l+s+sd}{        lX = liste d\PYGZsq{}objets ( é l é ment de R\PYGZca{}n) de longueur N}
\PYG{l+s+sd}{        y = objet ( é l é ment de R\PYGZca{}n)}
\PYG{l+s+sd}{        on dispose d\PYGZsq{}une fonction d}
\PYG{l+s+sd}{        qui mesure la distance entre objets}
\PYG{l+s+sd}{    sortie :}
\PYG{l+s+sd}{        lD = liste de float= liste des distances d(y,xk ) pour k dans [|1 , N |]}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{d}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{n}{x}\PYG{p}{)} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{LearningData}\PYG{p}{]}
    
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}


\subsection{Déterminer les k plus proches voisins}
\label{\detokenize{notebooks/Machine-Learning/KNN-Cours:determiner-les-k-plus-proches-voisins}}
\sphinxAtStartPar
Ensuite, il s’agit de déterminer les k plus proches voisins.Pour cela, on se contente d’utiliser l’algorithme de tri rapide en etulisant la fonction \sphinxstylestrong{sorted}.

\sphinxAtStartPar
Ici, on voit que l’on veut les indices des éléments les plus proches, pas les valeurs.En effet, ce n’est pas trier les distances qui nous intéressent mais trier les points.C’est pour cette raison nous n’allos pas utiliser \sphinxstylestrong{sorted} directement sur les distances mais nou allons utiliser la fonction \sphinxstylestrong{np.argsort} qui retourne la liste des indices des elements qui rendent la liste des distances une liste triée.
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Exemple }
\PYG{n}{distances}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}
\PYG{n}{indices}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{argsort}\PYG{p}{(}\PYG{n}{distances}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{les distances: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{distances}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{les indices: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{indices}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{ est l}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{indice de }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{ dans la liste distances, ce qui représente la distance minimale,}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{aisni }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{ est l}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{indice de  la distance maximale qui est }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{indices}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{distances}\PYG{p}{[}\PYG{n}{indices}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{indices}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{distances}\PYG{p}{[}\PYG{n}{indices}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
les distances:  [5, 10, 9, 11, 0.3]
les indices:  [4 0 2 1 3]
4 est l\PYGZsq{}indice de 0.3 dans la liste distances, ce qui représente la distance minimale,
aisni 3 est l\PYGZsq{}indice de  la distance maximale qui est 11
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{KNN}\PYG{p}{(}\PYG{n}{Ditanceslist}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    entrée :}
\PYG{l+s+sd}{            Ditanceslist = liste de float}
\PYG{l+s+sd}{               = liste des distances entre l\PYGZsq{}objet à placer }
\PYG{l+s+sd}{               y et chacun des objets de la liste d\PYGZsq{}apprentissages}
\PYG{l+s+sd}{            k = int = nombre de voisins à prendre en compte }
\PYG{l+s+sd}{    sortie : lKNN = liste de int de longueur K}
\PYG{l+s+sd}{      = liste des indices des K plus proches voisins .}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{argsort}\PYG{p}{(}\PYG{n}{Ditanceslist}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{n}{k}\PYG{p}{]}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{KNN\PYGZus{}version2}\PYG{p}{(}\PYG{n}{Ditanceslist}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{triee}\PYG{o}{=}\PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{Ditanceslist}\PYG{p}{)}\PYG{p}{,}\PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{e}\PYG{p}{:}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{k}{for} \PYG{n}{e} \PYG{o+ow}{in} \PYG{n}{triee}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{n}{k}\PYG{p}{]}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}


\subsection{Choisir la classe la plus fréquente}
\label{\detokenize{notebooks/Machine-Learning/KNN-Cours:choisir-la-classe-la-plus-frequente}}
\sphinxAtStartPar
Pour déterminer la classe la plus fréquente, il faut compter combien de fois est présente chaque classe.

\sphinxAtStartPar
Pour cela, on parcourt les k plus proches avec un compteur de longueur T (le nombre de classe).

\sphinxAtStartPar
Pour chaque élément lu, on incrémente le compteur correspondant.
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Compter}\PYG{p}{(}\PYG{n}{TargetValues}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{compteur}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{k}{for} \PYG{n}{e} \PYG{o+ow}{in} \PYG{n}{TargetValues}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{e} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{compteur}\PYG{p}{:}
            \PYG{n}{compteur}\PYG{p}{[}\PYG{n}{e}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{compteur}\PYG{p}{[}\PYG{n}{e}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
    \PYG{k}{return} \PYG{n}{compteur}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}

\sphinxAtStartPar
Ensuite, un simple algorithme de recherche de maximum donne la classe la plus fréquente.
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Plus\PYGZus{}commun}\PYG{p}{(}\PYG{n}{compteur}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{compteur}\PYG{p}{,}\PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{e}\PYG{p}{:}\PYG{n}{compteur}\PYG{p}{[}\PYG{n}{e}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}


\subsection{Prédire la Sortie d’une nouvelle donnée}
\label{\detokenize{notebooks/Machine-Learning/KNN-Cours:predire-la-sortie-d-une-nouvelle-donnee}}\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{predict}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{n}{LearningData}\PYG{p}{,}\PYG{n}{LearningTarget}\PYG{p}{,}\PYG{n}{d}\PYG{o}{=}\PYG{n}{d2\PYGZus{}np}\PYG{p}{,}\PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Ditanceslist}\PYG{o}{=}\PYG{n}{distances}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{n}{LearningData}\PYG{p}{,}\PYG{n}{d}\PYG{p}{)}
    \PYG{n}{voisins}\PYG{o}{=}\PYG{n}{KNN}\PYG{p}{(}\PYG{n}{Ditanceslist}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{Plus\PYGZus{}commun}\PYG{p}{(}\PYG{n}{Compter}\PYG{p}{(}\PYG{n}{LearningTarget}\PYG{p}{[}\PYG{n}{voisins}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}return Counter(LearningTarget[voisins]).most\PYGZus{}common()[0]}
    \PYG{c+c1}{\PYGZsh{}}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}


\subsection{Matrice de confusion}
\label{\detokenize{notebooks/Machine-Learning/KNN-Cours:matrice-de-confusion}}
\sphinxAtStartPar
La matrice de confusion permet de mesurer la qualité du système de classification.Pour tester la qualité, on prend M objets dont on connaît la classification.Cette classification est qualifiée de certaine.On applique l’algorithme à chacun de ses M objets et on note la classification obtenue (dite classification estimée).On met ces résultats dans une matrice : chaque ligne de la matrice correspond à une classe certaine, chaque colonne a une classe estimée. Ainsi ligne i et colonne j on met le nombre d’éléments qui ont été classifiée dans la classe j alors qu’ils sont dans la classe i.Si la classification était parfaite, alors seule la diagonale aurait des éléments non nuls.On considère qu’une classification est de qualité lorsque chaque ligne contient 95\% de ses valeurs sur l’élément diagonal.
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{ConfusionMatrix}\PYG{p}{(}\PYG{n}{TestData}\PYG{p}{,}\PYG{n}{TestTarget}\PYG{p}{,}\PYG{n}{model}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{LearningData}\PYG{p}{,}\PYG{n}{LearningTarget}\PYG{p}{,}\PYG{n}{d}\PYG{p}{,}\PYG{n}{k}\PYG{o}{=}\PYG{n}{model}
    \PYG{n}{types}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{set}\PYG{p}{(}\PYG{n}{TestTarget}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{n}\PYG{o}{=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{types}\PYG{p}{)}
    \PYG{n}{matrice}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{TestData}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{p}\PYG{o}{=}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{TestData}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{LearningData}\PYG{p}{,}\PYG{n}{LearningTarget}\PYG{p}{,}\PYG{n}{d}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}
        \PYG{n}{matrice}\PYG{p}{[}\PYG{n}{TestTarget}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}


\chapter{Tp Iris}
\label{\detokenize{notebooks/Machine-Learning/TP-Iris:tp-iris}}\label{\detokenize{notebooks/Machine-Learning/TP-Iris::doc}}\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{seaborn} \PYG{k}{as} \PYG{n+nn}{sns}
\PYG{k+kn}{from} \PYG{n+nn}{MyKNNLIB} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{MyKNNLIB} \PYG{k+kn}{import} \PYG{n}{predict}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}

\sphinxAtStartPar
On importe la célèbre base de sonnées iris. Elle contient des informations sur 3 variétés : Setosa, Versicolor et Virginica. Un ensemble de fleurs a été étudié. Pour chacune on a noté les informations suivantes : longueur et largueur des sépales, longueur et largeur des pétales.

\sphinxAtStartPar
On récupère la liste des informations sur les sépales et pétales :
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{sns}\PYG{o}{.}\PYG{n}{load\PYGZus{}dataset}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{iris}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data}\PYG{o}{.}\PYG{n}{head}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   sepal\PYGZus{}length  sepal\PYGZus{}width  petal\PYGZus{}length  petal\PYGZus{}width species
0           5.1          3.5           1.4          0.2  setosa
1           4.9          3.0           1.4          0.2  setosa
2           4.7          3.2           1.3          0.2  setosa
3           4.6          3.1           1.5          0.2  setosa
4           5.0          3.6           1.4          0.2  setosa
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{D} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{values}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{Y} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{values}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{D}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{]}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([[5.1, 3.5, 1.4, 0.2],
       [4.9, 3.0, 1.4, 0.2],
       [4.7, 3.2, 1.3, 0.2],
       [4.6, 3.1, 1.5, 0.2],
       [5.0, 3.6, 1.4, 0.2],
       [5.4, 3.9, 1.7, 0.4],
       [4.6, 3.4, 1.4, 0.3],
       [5.0, 3.4, 1.5, 0.2],
       [4.4, 2.9, 1.4, 0.2],
       [4.9, 3.1, 1.5, 0.1]], dtype=object)
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}

\sphinxAtStartPar
Chaque ligne de la matrice ci\sphinxhyphen{}dessus est l’enregistrement des données pour une fleur.
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Y}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{Y}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([\PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{},
        \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{},
        \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{},
        \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{},
        \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{},
        \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{},
        \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{},
        \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{},
        \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}setosa\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{},
        \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{},
        \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{},
        \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{},
        \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{},
        \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{},
        \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{},
        \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{},
        \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{},
        \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{},
        \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{},
        \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{},
        \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}versicolor\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{},
        \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{},
        \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{},
        \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{},
        \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{},
        \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{},
        \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{},
        \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{},
        \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{},
        \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{},
        \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}, \PYGZsq{}virginica\PYGZsq{}], dtype=object),
 150)
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Transform}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{setosa}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{versicolor}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{virginica}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Y}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Transform}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]} \PYG{k}{for} \PYG{n}{y} \PYG{o+ow}{in} \PYG{n}{Y}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{Y}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}

\sphinxAtStartPar
Le tableau Y indique, pour chaque numéro de ligne de D la catégorie à laquelle appartient la fleur correspondante (0 pour Setosa, 1 pour Versicolor et 2 pour Virginica).

\sphinxAtStartPar
Dit autrement, le tableau Y représente une partition de l’ensemble des données. La donnée numéro \(i\) appartient à la classe d’équivalence numéro Y{[}i{]}.

\sphinxAtStartPar
Ainsi, D{[}i{]} désigne les caractéristiques longueur et largeur des sépales de la fleur \(i\), longueur et largeur des pétales; et Y{[}i{]} représente la variété à laquelle elle appartient.

\sphinxAtStartPar
Le tableau D est appelé tableau des vecteurs caractéristiques; Y est le tableau des étiquettes de classe.

\sphinxAtStartPar
\sphinxincludegraphics{{rose}.png}

\sphinxAtStartPar
Dans tout ce qui suit D désigne une liste de coordonnées de points à classifier et Y les classes connues de ces points.

\sphinxAtStartPar
Pour fixer les idées on prendra D, Y égaux aux tableaux définis ci\sphinxhyphen{}dessus mais ce pourrait être tout autre chose.


\section{Question 1}
\label{\detokenize{notebooks/Machine-Learning/TP-Iris:question-1}}
\sphinxAtStartPar
On partitionne D et Y en deux groupes selon une fonction de choix f . Pour chaque numéro de ligne de D (et donc de Y ), f décide si on considère la fleur correspondante comme appartenant aux données d’apprentisage ou aux données de test. L’idéal est que f choississe aléatoirement, mais pour contrôler nos résultats nous prenons d’abord :
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{i}\PYG{p}{:}\PYG{n}{i}\PYG{o}{\PYGZpc{}}\PYG{k}{5}!=0
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{partitionner}\PYG{p}{(}\PYG{n}{D}\PYG{p}{,}\PYG{n}{Y}\PYG{p}{,}\PYG{n}{f}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{TestData}\PYG{p}{,}\PYG{n}{TestTarget}\PYG{p}{,}\PYG{n}{LearningData}\PYG{p}{,}\PYG{n}{LearningTarget}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{Y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{f}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{LearningData}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{D}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}\PYG{n}{LearningTarget}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{Y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{TestData}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{D}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}\PYG{n}{TestTarget}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{Y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{LearningData}\PYG{p}{,}\PYG{n}{LearningTarget}\PYG{p}{,}\PYG{n}{TestData}\PYG{p}{,}\PYG{n}{TestTarget}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}

\sphinxAtStartPar
cette fonction prend en paramètres une matrice D de données, un tableau Y de classes de ces données et renvoie 4 tableaux :
\begin{itemize}
\item {} 
\sphinxAtStartPar
le premier est une matrice constituée des lignes de D qui sont acceptées par la fonction f

\item {} 
\sphinxAtStartPar
le second est le tableau des classes correspondants aux données acceptées

\item {} 
\sphinxAtStartPar
les deux derniers tableaux correspondent aux données refusées et leurs classes

\end{itemize}

\sphinxAtStartPar
Les données acceptées (les deux premiers tableaux renvoyés) servent à l’apprentissage et les données refusées servent aux tests.

\sphinxAtStartPar
ensuite on convertit ces listes en des objets array pour faciliter leur exploitation
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Da}\PYG{p}{,}\PYG{n}{Ya}\PYG{p}{,}\PYG{n}{Dt}\PYG{p}{,}\PYG{n}{Yt} \PYG{o}{=} \PYG{n}{convert\PYGZus{}to\PYGZus{}np\PYGZus{}arrays}\PYG{p}{(}\PYG{n}{partitionner}\PYG{p}{(}\PYG{n}{D}\PYG{p}{,}\PYG{n}{Y}\PYG{p}{,}\PYG{n}{f}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}

\sphinxAtStartPar
Vouts trouverez la méthode convert\_to\_np\_arrays dans la laibrarie MyKNNLIB
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Da}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{c+c1}{\PYGZsh{} 2 premières données d\PYGZsq{}apprentissage}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Dt}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{c+c1}{\PYGZsh{} 2 premières données de test}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[4.9 3.0 1.4 0.2]
 [4.7 3.2 1.3 0.2]]
[[5.1 3.5 1.4 0.2]
 [5.4 3.9 1.7 0.4]]
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}

\sphinxAtStartPar
Ecrire la fonction d2(x,y) qui calcule la distance entre deux points x, y de mêmes imensions

\sphinxAtStartPar
void la définition dan dans la parie cours ou bien dans le fichier \sphinxhref{http://MYKNNLIB.py}{MYKNNLIB.py}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{d2}\PYG{p}{(}\PYG{n}{D}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{D}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0.5385164807134502
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}

\sphinxAtStartPar
On détermine maintenant la variété de la fleur étudiée \sphinxstylestrong{Fleur}.
On lui attribue la variété   majoritaire parmi ses k plus proches voisins.

\sphinxAtStartPar
Ecrire la fonction qui prend en paramètre le dictionnaire des noms de classes, une liste de voisins d’un point et le nom d’étiquette majoritaire parmi ces voisins.
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Fluer}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{predict}\PYG{p}{(}\PYG{n}{Fluer}\PYG{p}{,}\PYG{n}{Da}\PYG{p}{,}\PYG{n}{Ya}\PYG{p}{,}\PYG{n}{d}\PYG{o}{=}\PYG{n}{d2}\PYG{p}{,}\PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{11}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}

\sphinxAtStartPar
Ainsi le type predit de cette fleur est 0 c’est à dire le setosa
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TestData}\PYG{p}{,}\PYG{n}{TestTarget}\PYG{p}{,}\PYG{n}{LearningData}\PYG{p}{,}\PYG{n}{LearningTarget}\PYG{o}{=}\PYG{n}{convert\PYGZus{}to\PYGZus{}np\PYGZus{}arrays}\PYG{p}{(}\PYG{n}{partitionner}\PYG{p}{(}\PYG{n}{D}\PYG{p}{,}\PYG{n}{Y}\PYG{p}{,}\PYG{n}{f}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{=}\PYG{n}{LearningData}\PYG{p}{,}\PYG{n}{LearningTarget}\PYG{p}{,}\PYG{n}{d1\PYGZus{}np}\PYG{p}{,}\PYG{l+m+mi}{3}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}

\sphinxAtStartPar
Pour testerla fiabilité du modèle on calcule la matrice de confusion dont le principe est expliqé dans la partie cours
\begin{sphinxVerbatimInput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{matrice}\PYG{o}{=}\PYG{n}{ConfusionMatrix}\PYG{p}{(}\PYG{n}{TestData}\PYG{p}{,}\PYG{n}{TestTarget}\PYG{p}{,}\PYG{n}{model}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{matrice}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[40.  0.  0.]
 [ 0. 39.  1.]
 [ 0. 12. 28.]]
\end{sphinxVerbatim}
\end{sphinxVerbatimOutput}

\begin{sphinxthebibliography}{JPBecirs}
\bibitem[JPBecirspahic]{intro:id7}
\sphinxAtStartPar
Jean\sphinxhyphen{}Pierre\sphinxhyphen{}Becirspahic. Arbres binaires. \sphinxurl{https://info-llg.fr/option-mp/pdf/01.arbres.pdf}. Accessed: 2010\sphinxhyphen{}09\sphinxhyphen{}30.
\end{sphinxthebibliography}







\renewcommand{\indexname}{Index}
\printindex
\end{document}